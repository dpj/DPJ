<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>

<HEAD>

<TITLE>The Deterministic Parallel Java Language
 Reference Manual 
Version 1.0</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.08">
<STYLE type="text/css">
.toc{list-style:none;}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
.part{margin:auto;text-align:center}
.lstlisting{font-family:monospace;white-space:pre;margin-right:auto;margin-left:0pt;text-align:left}
.verbatim{margin:1ex 1ex;padding:1ex;}
.dpjlisting{font-family:monospace;white-space:pre;
margin:1ex 1ex;padding:1ex;}
.numbereddpjlisting{font-family:monospace;white-space:pre;
margin:1ex 1ex;padding:1ex 1ex 1ex 0ex;}
BODY{backgroundcolor:white}
.title{padding:1ex;background:#B24D00}
.titlemain{padding:1ex;background:#B24D00}
.titlerest{padding:1ex;background:#B24D00}
.part{padding:1ex;background:#CC5800}
.section{padding:.5ex;background:#E57D2D}
.subsection{padding:0.3ex;background:#FFA866}
.subsubsection{padding:0.5ex;background:#FFC598}
.ftoc1{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid transparent;}
.ftoc2{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid transparent;}
.ftoc3{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid transparent;}
.ftoc4{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid transparent;}
.ftoc5{list-style:none;margin:0ex 1ex;padding:0ex 1ex;border-left:1ex solid transparent;}
</STYLE>
</HEAD>

<BODY >
<!--HEVEA command line is: hevea -fix -O DPJReferenceManual.tex -->
<!--HTMLHEAD-->
<!--ENDHTML-->
<!--PREFIX <ARG ></ARG>-->
<!--CUT DEF section 0 -->

<BR>
<TABLE CLASS="title">
<TR><TD>
<H1 CLASS="titlemain"><B>The Deterministic Parallel Java Language
 Reference Manual<BR>
Version 1.0</B></H1>
<H3 CLASS="titlerest">University of Illinois at Urbana-Champaign</H3>
<H3 CLASS="titlerest">Revised June 2010</H3></TD>
</TR></TABLE><BR>
<!--TOC section Contents-->

<H2 CLASS="section">Contents</H2><!--SEC END -->

<UL CLASS="ftoc1"><LI CLASS="li-toc">
<A HREF="#htoc1">1&nbsp;&nbsp;Introduction</A>
<LI CLASS="li-toc"><A HREF="#htoc2">2&nbsp;&nbsp;Classes and Interfaces</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc3">2.1&nbsp;&nbsp;Class Region Name Declarations</A>
<LI CLASS="li-toc"><A HREF="#htoc4">2.2&nbsp;&nbsp;Field RPL Specifiers</A>
<LI CLASS="li-toc"><A HREF="#htoc5">2.3&nbsp;&nbsp;Methods</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc6">2.3.1&nbsp;&nbsp;Effect Summaries (Non-Constructor Methods)</A>
<LI CLASS="li-toc"><A HREF="#htoc7">2.3.2&nbsp;&nbsp;Effect Summaries (Constructors)</A>
<LI CLASS="li-toc"><A HREF="#htoc8">2.3.3&nbsp;&nbsp;Local Region Name Declarations</A>
<LI CLASS="li-toc"><A HREF="#htoc9">2.3.4&nbsp;&nbsp;Commutative Methods</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc10">2.4&nbsp;&nbsp;Region Parameters</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc11">2.4.1&nbsp;&nbsp;Class Region Parameters</A>
<LI CLASS="li-toc"><A HREF="#htoc12">2.4.2&nbsp;&nbsp;Method Region Parameters</A>
<LI CLASS="li-toc"><A HREF="#htoc13">2.4.3&nbsp;&nbsp;Disjointness Constraints</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc14">3&nbsp;&nbsp;Region Path Lists (RPLs)</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc15">3.1&nbsp;&nbsp;Basic Region Names</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc16">3.1.1&nbsp;&nbsp;The Name <TT>Root</TT></A>
<LI CLASS="li-toc"><A HREF="#htoc17">3.1.2&nbsp;&nbsp;Class Region Names</A>
<LI CLASS="li-toc"><A HREF="#htoc18">3.1.3&nbsp;&nbsp;Array Index RPLs</A>
<LI CLASS="li-toc"><A HREF="#htoc19">3.1.4&nbsp;&nbsp;Local Region Names</A>
<LI CLASS="li-toc"><A HREF="#htoc20">3.1.5&nbsp;&nbsp;<TT>final</TT> Local Variables and <TT>this</TT> as Region Names</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc21">3.2&nbsp;&nbsp;Sequences of Basic Names</A>
<LI CLASS="li-toc"><A HREF="#htoc22">3.3&nbsp;&nbsp;Parameterized RPLs</A>
<LI CLASS="li-toc"><A HREF="#htoc23">3.4&nbsp;&nbsp;Partially Specified RPLs</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc24">3.4.1&nbsp;&nbsp;The <TT>*</TT> RPL Element</A>
<LI CLASS="li-toc"><A HREF="#htoc25">3.4.2&nbsp;&nbsp;The <TT>[?]</TT> RPL Element</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc26">3.5&nbsp;&nbsp;Local RPLs</A>
<LI CLASS="li-toc"><A HREF="#htoc27">3.6&nbsp;&nbsp;Comparing RPLs</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc28">3.6.1&nbsp;&nbsp;Equivalence</A>
<LI CLASS="li-toc"><A HREF="#htoc29">3.6.2&nbsp;&nbsp;Nesting</A>
<LI CLASS="li-toc"><A HREF="#htoc30">3.6.3&nbsp;&nbsp;Inclusion</A>
<LI CLASS="li-toc"><A HREF="#htoc31">3.6.4&nbsp;&nbsp;Disjointness</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc32">4&nbsp;&nbsp;Types</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc33">4.1&nbsp;&nbsp;Class and Interface Types
</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc34">4.1.1&nbsp;&nbsp;Writing Class Types</A>
<LI CLASS="li-toc"><A HREF="#htoc35">4.1.2&nbsp;&nbsp;Class Type Comparisons</A>
<LI CLASS="li-toc"><A HREF="#htoc36">4.1.3&nbsp;&nbsp;Class Type Casts</A>
<LI CLASS="li-toc"><A HREF="#htoc37">4.1.4&nbsp;&nbsp;Owner RPLs</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc38">4.2&nbsp;&nbsp;Array Types</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc39">4.2.1&nbsp;&nbsp;Writing Array Types</A>
<LI CLASS="li-toc"><A HREF="#htoc40">4.2.2&nbsp;&nbsp;Index-Parameterized Array Types</A>
<LI CLASS="li-toc"><A HREF="#htoc41">4.2.3&nbsp;&nbsp;New Arrays</A>
<LI CLASS="li-toc"><A HREF="#htoc42">4.2.4&nbsp;&nbsp;Array Type Comparisons</A>
<LI CLASS="li-toc"><A HREF="#htoc43">4.2.5&nbsp;&nbsp;Array Type Casts</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc44">4.3&nbsp;&nbsp;Typing Expressions</A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc45">4.3.1&nbsp;&nbsp;Field Access</A>
<LI CLASS="li-toc"><A HREF="#htoc46">4.3.2&nbsp;&nbsp;Array Access</A>
<LI CLASS="li-toc"><A HREF="#htoc47">4.3.3&nbsp;&nbsp;Method Invocation</A>
<LI CLASS="li-toc"><A HREF="#htoc48">4.3.4&nbsp;&nbsp;Captured Types</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc49">5&nbsp;&nbsp;Effects</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc50">5.1&nbsp;&nbsp;Basic Effects</A>
<LI CLASS="li-toc"><A HREF="#htoc51">5.2&nbsp;&nbsp;Effect Summaries</A>
<LI CLASS="li-toc"><A HREF="#htoc52">5.3&nbsp;&nbsp;Local Effects</A>
<LI CLASS="li-toc"><A HREF="#htoc53">5.4&nbsp;&nbsp;Effects of Statements and Expressions</A>
<LI CLASS="li-toc"><A HREF="#htoc54">5.5&nbsp;&nbsp;Effect Coarsening</A>
<LI CLASS="li-toc"><A HREF="#htoc55">5.6&nbsp;&nbsp;Subeffects</A>
<LI CLASS="li-toc"><A HREF="#htoc56">5.7&nbsp;&nbsp;Noninterference of effect</A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc57">6&nbsp;&nbsp;Parallel Control Flow</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc58">6.1&nbsp;&nbsp;<TT>cobegin</TT></A>
<LI CLASS="li-toc"><A HREF="#htoc59">6.2&nbsp;&nbsp;<TT>foreach</TT></A>
<UL CLASS="ftoc3"><LI CLASS="li-toc">
<A HREF="#htoc60">6.2.1&nbsp;&nbsp;Writing the <TT>foreach</TT> loop</A>
<LI CLASS="li-toc"><A HREF="#htoc61">6.2.2&nbsp;&nbsp;Controlling the granularity of parallelism</A>
</UL>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc62">7&nbsp;&nbsp;The DPJ Runtime</A>
<UL CLASS="ftoc2"><LI CLASS="li-toc">
<A HREF="#htoc63">7.1&nbsp;&nbsp;<TT>DPJArray</TT></A>
<LI CLASS="li-toc"><A HREF="#htoc64">7.2&nbsp;&nbsp;<TT>DPJPartition</TT></A>
</UL>
<LI CLASS="li-toc"><A HREF="#htoc65">8&nbsp;&nbsp;Exception Behavior</A>
</UL>
<!--NAME contents.html-->
<BR>
<BR>
<!--TOC section 1&nbsp;&nbsp;Introduction-->

<H2 CLASS="section"><A NAME="htoc1">1</A>&nbsp;&nbsp;Introduction<A NAME="sec:introduction"></A></H2><!--SEC END -->

<!--NAME introduction.html-->
<BR>
<BR>
This document is a reference guide to the Deterministic Parallel Java
programming language, Version 1.0 (DPJ v1.0). It explains in detail
the new language features that DPJ adds to Java, and how they work.
It is intended to be accessible to readers with no previous knowledge
of DPJ, though familiarity with Java is assumed. <BR>
<BR>
Many cross-references appear throughout the document. To refer to
sections, we use the section symbol §: for example,
§&nbsp;<A HREF="#sec:effects:basic">5.1</A> refers to the section numbered
<A HREF="#sec:effects:basic">5.1</A>.<BR>
<BR>
Readers of this document may also wish to consult the following:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<EM>The Deterministic Parallel Java Tutorial</EM> provides a tutorial introduction to DPJ, and
 explains how to write some common parallel patterns in DPJ. The DPJ
 programmer should probably read that document first. It
 cross-references this document, so you can look up particular
 features that you want to learn more about.
<LI CLASS="li-itemize"><EM>The Deterministic Parallel Java Installation and Testing Guide</EM> explains how to get started installing the
 <TT>dpjc</TT> compiler, using the compiler to compile DPJ programs, and
 running DPJ programs.
<LI CLASS="li-itemize"><EM>The Deterministic Parallel Java Language Specification</EM> gives the specification of DPJ more precisely. The
 reference manual you are reading is sufficiently detailed that most
 if not all of the specification can be gleaned from it; but the
 specification is both more precise and more concise than this
 document. It will be most useful to someone who is already familiar
 with and understands this manual.
</UL>
The rest of the document is organized as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
§&nbsp;<A HREF="#sec:classes">2</A>, <EM>Classes and Interfaces</EM>, describes
 DPJ's extensions to Java classes and interfaces. These include
 features for declaring region names, using assigning region names to
 class fields, summarizing method effects, and writing classes and
 methods with region variables.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:rpls">3</A>, <EM>Region Path Lists</EM>, describes region
 path lists, or RPLs. These are the general form of a region name in
 DPJ. RPLs are hierarchically structured, and the structure allows
 many fine distinctions between sets of regions to be expressed.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:types">4</A>, <EM>Types</EM>, describes DPJ's extensions to
 Java's class and array types. The main difference is that both
 class and array types can have region arguments. There are also new
 rules for type comparisons, casts, etc. to support the extensions.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:effects">5</A>, <EM>Effects</EM>, describes DPJ's effect
 system, which is closely integrated with the regions in the type
 system. Effects describe operations on the heap. The programmer
 declares the effects of methods, and the compiler infers the rest of
 the effects. The compiler checks to make sure that the effects of
 parallel tasks are mutually noninterfering.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:parallel">6</A>, <EM>Parallel Control Flow</EM>, describes
 DPJ's constructs for creating parallel tasks.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:runtime">7</A>, <EM>The DPJ Runtime</EM>, explains the classes in
 the DPJ runtime that are useful for manipulating arrays.
<LI CLASS="li-itemize">§&nbsp;<A HREF="#sec:exceptions">8</A>, <EM>Exception Behavior</EM>, explains
 what happens when an exception is thrown in DPJ.
</UL>

<!--TOC section 2&nbsp;&nbsp;Classes and Interfaces-->

<H2 CLASS="section"><A NAME="htoc2">2</A>&nbsp;&nbsp;Classes and Interfaces<A NAME="sec:classes"></A></H2><!--SEC END -->

<!--NAME classes.html-->
<BR>
<BR>
DPJ classes and interfaces are identical to classes and interfaces in
Java, with the following additional features:
<UL CLASS="itemize"><LI CLASS="li-itemize">
New members called <EM>class region name declarations</EM>
 (§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>) declare region names at class or
 interface scope that can be associated with class fields
 (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>).
<LI CLASS="li-itemize">Methods have several new features to support regions and effects
 (§&nbsp;<A HREF="#sec:classes:methods">2.3</A>).
<LI CLASS="li-itemize">Classes, interfaces, and methods support <EM>region
 parameters</EM>, so that different objects of the same class or
 interface, and different invocations of the same method, can use
 different regions (§&nbsp;<A HREF="#sec:classes:params">2.4</A>).
</UL>
Throughout this section, we use the term &#8220;class&#8221; with the
understanding that the concepts apply identically to interfaces,
unless otherwise noted.<BR>
<BR>
<!--TOC subsection 2.1&nbsp;&nbsp;Class Region Name Declarations-->

<H3 CLASS="subsection"><A NAME="htoc3">2.1</A>&nbsp;&nbsp;Class Region Name Declarations<A NAME="sec:classes:region-names"></A></H3><!--SEC END -->

<!--NAME classes.region-names.html-->
<BR>
<BR>
A <EM>class region name declaration</EM> may appear as a class or
interface member. A class region name declaration consists of the
keyword <TT>region</TT> followed by one or more identifiers separated by
commas. For example, the following declaration declares a region name
<TT>Data</TT> within the class <TT>Element</TT>:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><B>class</B> Element {
 <FONT COLOR="blue"><B>region</B></FONT> Data;
 ...
}</TT></DIV><BR>
<BR>
Class region name declarations function like static class members in
Java (though the keyword <TT>static</TT> need not be used with a class
region declaration &mdash; if it is, it has no effect). In particular,
subject to visibilty restrictions, other packages and classes can
refer to the declared names by prepending the proper package and class
qualifiers. For example, outside of class <TT>Element</TT>, region
<TT>Data</TT> could be referred to as <TT>Element.Data</TT>.<BR>
<BR>
As with Java fields and methods, the programmer may control the access
to the declared names with the qualifiers <TT>public</TT>, <TT>private</TT>,
or <TT>protected</TT>. For example, the following code declares two
regions that can be referred to from anywhere in the program:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><B>class</B> Node {
 <B>public <FONT COLOR="blue">region</FONT></B> Left, Right;
 ...
}</TT></DIV><BR>
<BR>
Class region name declarations are available for use in RPLs
(§&nbsp;<A HREF="#sec:rpls">3</A>) in the scope where they are visible. A class
region name standing alone is a particular case of an RPL (see
§&nbsp;<A HREF="#sec:rpls:basic:class">3.1.2</A>).<BR>
<BR>
<!--TOC subsection 2.2&nbsp;&nbsp;Field RPL Specifiers-->

<H3 CLASS="subsection"><A NAME="htoc4">2.2</A>&nbsp;&nbsp;Field RPL Specifiers<A NAME="sec:classes:field-region-spec"></A></H3><!--SEC END -->

<!--NAME classes.field-region-spec.html-->
<BR>
<BR>
Every class field in DPJ resides in a <EM>region</EM>, named with a
region path list (§&nbsp;<A HREF="#sec:rpls">3</A>). This is a fundamental aspect of
DPJ versus plain Java; it allows the specification and checking of
effects (§&nbsp;<A HREF="#sec:effects">5</A>). There are two ways to specify the RPL
of a field: (1) with an explicit <EM>field RPL specifier</EM>; and (2)
by using the <EM>default field RPL</EM>.<BR>
<BR>
<B>Explicit field RPL specifiers:</B> A field RPL specifier has the
following form:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>in</TT> <EM>rpl</EM>
</DL>
<EM>rpl</EM> is an RPL, as defined in §&nbsp;<A HREF="#sec:rpls">3</A>. If the field
RPL specifier is present, then it must appear immediately after the
field name (and before the field initializer expression, if there is
one). For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> FieldRPLSpecifiers {
    <FONT COLOR="blue"><B>region</B></FONT> X, Y;             <FONT COLOR="fuchsia"><EM>// X and Y name regions</EM></FONT>
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X;              <FONT COLOR="fuchsia"><EM>// field x is in region X</EM></FONT>
    <B>boolean</B> y <FONT COLOR="blue"><B>in</B></FONT> Y = <B>false</B>;  <FONT COLOR="fuchsia"><EM>// field y is in region Y</EM></FONT>
}</TT></DIV>Notice that because a class region name declaration functions like a
static class member (§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>), it creates a
single region name <EM>per class</EM>, not per object. Therefore, a
field RPL specifier such as <TT>int x in X</TT> assigns the same
region <TT>FieldRPLSpecifiers.X</TT> to the field of <EM>every object
 instance</EM> of class <TT>FieldRPLSpecifiers</TT> created at runtime.
§&nbsp;<A HREF="#sec:classes:params">2.4</A> explains how to use <EM>region
 parameters</EM> to assign different regions to the fields of different
objects of the same class.<BR>
<BR>
<EM>Final fields:</EM> Effects on <TT>final</TT> fields are ignored
(§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A>), because their values never change
after initialization. Therefore, field RPL specifiers are not
meaningful for <TT>final</TT> fields. If a field is declared
<TT>final</TT>, then an RPL specifier may be given for the field; but if
so, it is ignored.<BR>
<BR>
<B>Default field RPL:</B> If a field has no explicit RPL specifier,
then its RPL is <TT>Root</TT>. The name <TT>Root</TT> is always in scope
(§&nbsp;<A HREF="#sec:rpls:basic:root">3.1.1</A>). For example, in the following code,
field <TT>x</TT> is in region <TT>Root</TT>:

 <DIV CLASS="dpjlisting"><TT><B>class</B> DefaultRegionSpecifier {
    <FONT COLOR="fuchsia"><EM>// Equivalent to int x in Root = 5</EM></FONT>
    <B>int</B> x = 5;
}</TT></DIV><BR>
<BR>
<!--TOC subsection 2.3&nbsp;&nbsp;Methods-->

<H3 CLASS="subsection"><A NAME="htoc5">2.3</A>&nbsp;&nbsp;Methods<A NAME="sec:classes:methods"></A></H3><!--SEC END -->

<!--NAME classes.methods.html-->
<BR>
<BR>
DPJ adds the following features to Java methods:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Every method (§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>) and
 constructor (§&nbsp;<A HREF="#sec:classes:methods:summaries-constructor">2.3.2</A>)
 summarizes its effects, either explicitly or through a default
 effect summary.
<LI CLASS="li-itemize">The programmer may declare and use <EM>local region names</EM>
 inside a method body (§&nbsp;<A HREF="#sec:classes:methods:local-regions">2.3.3</A>),
 to express effects that do not escape the method scope.
<LI CLASS="li-itemize">Methods may be marked <TT>commutative</TT> to indicate that their
 effects commute, even though they have conflicting reads and writes
 (§&nbsp;<A HREF="#sec:classes:methods:commutative">2.3.4</A>).
</UL>
<!--TOC subsubsection 2.3.1&nbsp;&nbsp;Effect Summaries (Non-Constructor Methods)-->

<H4 CLASS="subsubsection"><A NAME="htoc6">2.3.1</A>&nbsp;&nbsp;Effect Summaries (Non-Constructor Methods)<A NAME="sec:classes:methods:summaries"></A></H4><!--SEC END -->

<!--NAME classes.methods.summaries-->
<BR>
<BR>
Every DPJ method must summarize its effects. The compiler uses the
summaries to check noninterference of effect
(§&nbsp;<A HREF="#sec:effects:nonint">5.7</A>). This section discusses effect
summaries for non-constructor methods.
§&nbsp;<A HREF="#sec:classes:methods:summaries-constructor">2.3.2</A> describes effects
summaries for constructors. There are two ways to summarize a
method's effects: (1) with an explicit method effect summary; or (2)
with the default method effect summary.<BR>
<BR>
<B>Explicit method effect summaries:</B> An explicit method effect
summary appears immediately after the method's value parameters and
before the <TT>throws</TT> clause, if any. It has the form given in
§&nbsp;<A HREF="#sec:effects:summaries">5.2</A>. For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Summaries {
  <FONT COLOR="blue"><B>region</B></FONT> X, Y;
  <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X;
  <B>int</B> y <FONT COLOR="blue"><B>in</B></FONT> Y;
  <FONT COLOR="fuchsia"><EM>// pureMethod has no effect on the heap</EM></FONT>
  <B>int</B> pureMethod(<B>int</B> y) <FONT COLOR="blue"><B>pure</B></FONT> { <B>return</B> y+1; }
  <FONT COLOR="fuchsia"><EM>// throwsMethod reads r1 and throws an exception</EM></FONT>
  <B>void</B> throwsMethod() <FONT COLOR="blue"><B>reads</B></FONT> r1 <B>throws</B> Exception {
    <B>if</B> (x != 0) <B>throw new</B> Exception();
  }
  <FONT COLOR="fuchsia"><EM>// readWriteMethod reads r2 and writes r1</EM></FONT>
  <B>void</B> readWriteMethod() <FONT COLOR="blue"><B>reads</B></FONT> r2 <FONT COLOR="blue"><B>writes</B></FONT> r1 {
    x = y;
  }
}</TT></DIV><BR>
<BR>
A method effect summary must represent all the effects of the method
body. More precisely, the actual method effects must be a
<EM>subeffect</EM> (§&nbsp;<A HREF="#sec:effects:subeffects">5.6</A>) of the summarized
effects. The actual effects are computed as described in
§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A>, <EM>except</EM> that any local effect
(§&nbsp;<A HREF="#sec:effects:local">5.3</A>) can be omitted from the summary. The
representation can be conservative, i.e., it is permissible to include
effects in the summary that can never occur in executing the method.
But if any effect of any possible execution of the method is omitted
from the summary, it is a compile-time error. <BR>
<BR>
For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> MoreSummaries {
  <FONT COLOR="blue"><B>region</B></FONT> X;
  <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X;
  <FONT COLOR="fuchsia"><EM>// OK, summary is conservative</EM></FONT>
  <B>int</B> readsMethod() <FONT COLOR="blue"><B>writes</B></FONT> X {
    <FONT COLOR="fuchsia"><EM>// Write effects cover reads</EM></FONT>
    <B>return</B> x;
  }
  <FONT COLOR="fuchsia"><EM>// Error!  Read effect must be reported</EM></FONT>
  <B>int</B> pureMethod() <FONT COLOR="blue"><B>pure</B></FONT> {
    <B>return</B> x;
  }
}</TT></DIV><BR>
<BR>
A method effect summary must also represent all the effects of any
method that overrides it. If it does not, then there is a
compile-time error. To see why, consider the following classes:

 <DIV CLASS="dpjlisting"><TT><B>class</B> SuperClass {
  <FONT COLOR="blue"><B>region</B></FONT> X;
  <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X;
  <B>void</B> method(<B>int</B> x) <FONT COLOR="blue"><B>writes</B></FONT> X {
    <B>this</B>.x = x;
  }
}
<B>class</B> SubClass <B>extends</B> SuperClass {
  <FONT COLOR="fuchsia"><EM>// Compile-time error:  pure does not cover writes X</EM></FONT>
  <B>void</B> method(<B>int</B> x) <FONT COLOR="blue"><B>pure</B></FONT> {
    <FONT COLOR="fuchsia"><EM>// Do nothing</EM></FONT>
  }
}</TT></DIV>The method <TT>method</TT> defined in <TT>SubClass</TT> overrides the method
<TT>method</TT> defined in <TT>SuperClass</TT>. There is an error in the
code, because the effect <TT>pure</TT> of the subclass method does not
cover the effect <TT>writes X</TT> of the superclass method. While this
may look innocuous (after all, the <TT>SubClass</TT> version of method
really has no effect!), suppose we allowed the code given above and
then wrote the following method:

 <DIV CLASS="dpjlisting"><TT><B>void</B> callMethod(SubClass subClass) <FONT COLOR="blue"><B>pure</B></FONT> {
  subClass.method();
}</TT></DIV>Based on the previous code, this looks fine: we are calling
<TT>subClass.method</TT>, which has effect <TT>pure</TT>. But does it?
Because of polymorphic dispatch, the <EM>runtime</EM> type of the object
bound to <TT>subClass</TT> could be <TT>SuperClass</TT>. And in that case,
the call to <TT>method</TT> would invoke the <EM>superclass</EM> version of
<TT>method</TT>, which has the effect <TT>writes X</TT>. The write to
region <TT>X</TT> would be &#8220;hidden&#8221; by the polymorphic dispatch. To
prevent this kind of hiding, DPJ requires that superclass effects
cover subclass effects. Notice that if we change the effect summary
in the <TT>SubClass</TT> version of <TT>method</TT> to <TT>writes X</TT>, as
DPJ requires, then this problem goes away.<BR>
<BR>
<B>Default effect summary:</B> Any DPJ method may be written with no
explicit method effect summary. In particular, an ordinary Java
method is always a valid DPJ method.<BR>
<BR>
If a method lacks an explicit effect summary, then the compiler
assigns it the default summary <TT>writes Root:*</TT>. This is the most
conservative possible effect summary; it says that the method may read
or write to any globally-visible memory location. The default effect
summary is always valid, because it covers all possible effects of any
method. For example, the following code is valid:

 <DIV CLASS="dpjlisting"><TT><B>class</B> DefaultEffectSummary {
    <FONT COLOR="fuchsia"><EM>// Equivalent to 'void method() writes Root:*'
    // OK, because effects may be overreported</EM></FONT>
    <B>void</B> defaultSummary() {
        <FONT COLOR="fuchsia"><EM>// No actual effect!</EM></FONT>
    }
    <B>void</B> parallel() {
        <FONT COLOR="fuchsia"><EM>// Reports interference, even though defaultSummary has no
        // actual effect!</EM></FONT>
        <FONT COLOR="blue"><B>cobegin</B></FONT> {
           defaultSummary();
           defaultSummary();
        }
    }
}</TT></DIV><BR>
<BR>
In general, the default effect summary is too coarse-grained for
methods that are called either directly or indirectly inside a
parallel task: as shown in the example, it causes DPJ to detect and
warn about interfering writes, even if the method's actual effects are
not interfering. However, for methods that are only ever used in
sequential parts of the program, the default effect summary saves
effort, because the effects of those methods are not important.<BR>
<BR>
<!--TOC subsubsection 2.3.2&nbsp;&nbsp;Effect Summaries (Constructors)-->

<H4 CLASS="subsubsection"><A NAME="htoc7">2.3.2</A>&nbsp;&nbsp;Effect Summaries (Constructors)<A NAME="sec:classes:methods:summaries-constructor"></A></H4><!--SEC END -->

<!--NAME classes.methods.summaries-constructor-->
<BR>
<BR>
Constructors are special methods; therefore they must also summarize
their effects. All the rules given in
§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A> apply, with one important
exception: the effect summary of a constructor does <EM>not</EM> have to
report any initialization effects on fields of the object being
constructed. For example, the following code is legal:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ConstructorExample {
    <FONT COLOR="blue"><B>region</B></FONT> X, Y;
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X, y <FONT COLOR="blue"><B>in</B></FONT> Y;
    <FONT COLOR="fuchsia"><EM>// Effect 'pure' is valid, because initialization effects
    // on x and y don't have to be reported</EM></FONT>
    ConstructorExample(<B>int</B> x, <B>int</B> y) <FONT COLOR="blue"><B>pure</B></FONT> {
        <B>this</B>.x = x;
        <B>this</B>.y = y;
    }
}</TT></DIV>This works because the DPJ type and effect system guarantees that if
one parallel task calls a constructor, then the fields of a
constructed object are never read by any other parallel task until the
first task is finished. In particular, that means that no other
parallel task can ever see object fields in an uninitialized state.
So there can be no interference due to initialization effects of
constructors.<BR>
<BR>
However, if we wrote the same initializer as a non-constructor method,
then the rules in §&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A> would apply,
and we would have to write the effects:

 <DIV CLASS="dpjlisting"><TT><B>class</B> NonConstructorExample {
    <FONT COLOR="blue"><B>region</B></FONT> X, Y;
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> X, y <FONT COLOR="blue"><B>in</B></FONT> Y;
    <FONT COLOR="fuchsia"><EM>// Effect 'pure' would cause a compile error here</EM></FONT>
    <B>static void</B> initialize(<B>int</B> x, <B>int</B> y) <FONT COLOR="blue"><B>writes</B></FONT> X, Y {
        <B>this</B>.x = x;
        <B>this</B>.y = y;
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 2.3.3&nbsp;&nbsp;Local Region Name Declarations-->

<H4 CLASS="subsubsection"><A NAME="htoc8">2.3.3</A>&nbsp;&nbsp;Local Region Name Declarations<A NAME="sec:classes:methods:local-regions"></A></H4><!--SEC END -->

<!--NAME classes.methods.local-regions-->
<BR>
<BR>
A region name declaration may appear as a statement in the body of a
method. This kind of declaration is called a <EM>local region name
 declaration</EM>. Like a class region name declaration
(§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>), a local region name declaration
consists of the keyword <TT>region</TT> followed by a comma-separated
list of identifiers. The declared names are available for use in RPLs
(§&nbsp;<A HREF="#sec:rpls">3</A>) in the scope of the enclosing statement block. In
particular, a local region name standing alone is a valid RPL
(§&nbsp;<A HREF="#sec:rpls:basic:local">3.1.4</A>).<BR>
<BR>
For example, the following code declares
region names <TT>A</TT> and <TT>B</TT> that are available for use as region
names in the scope of method <TT>localRegionNames</TT>:

 <DIV CLASS="dpjlisting"><TT><B>void</B> localRegionNames() {
 <FONT COLOR="blue"><B>region</B></FONT> A, B;
 ...
}</TT></DIV><BR>
<BR>
Because of their limited scope, local names (and RPLs constructed from
them) cannot appear in field RPL specifiers
(§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>). They can be used
<EM>only</EM> in arguments to class or method region parameters
(§&nbsp;<A HREF="#sec:classes:params">2.4</A>). Their purpose is to indicate that the
effects of operating on the class object, or invoking the method, are
local to the enclosing method, and need not to be reported in the
effect summary of the enclosing method or constructor
(§§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>,&nbsp;<A HREF="#sec:classes:methods:summaries-constructor">2.3.2</A>).
This technique is called <EM>effect masking</EM>. For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> EffectMasking&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
  <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
  <FONT COLOR="fuchsia"><EM>// method has no globally-visible effect</EM></FONT>
  <B>void</B> method() <FONT COLOR="blue"><B>pure</B></FONT> {
    <FONT COLOR="fuchsia"><EM>// Declare region r local to method</EM></FONT>
    <FONT COLOR="blue"><B>region</B></FONT> r;
    <FONT COLOR="fuchsia"><EM>// Use local region to create new EffectMasking object
    // 'masking' cannot escape method</EM></FONT>
    EffectMasking&lt;r&gt; masking = <B>new</B> EffectMasking&lt;r&gt;();
    <FONT COLOR="fuchsia"><EM>// Effect 'writes r' is masked from callees</EM></FONT>
    masking.x = 0;
  }
}</TT></DIV>In this example the masked effect is somewhat useless. But there are
plenty of realistic cases where objects are created and assigned to
temporarily to support some computation, then thrown away because only
the final result is needed by the callee. By creating the temporary
objects with local regions, the callee can reduce its effect
signature, minimizing potential interference and making it more useful
inside parallel tasks. See <EM>The Deterministic Parallel Java Tutorial</EM> for more details.<BR>
<BR>
Like Java local variables, a local region name declared in a statement
block is in scope only in that block; its scope ends when the block
ends. For example, the following code would cause a compile error,
because the name <TT>OutOfScopeRegion</TT> is not in scope where it is
used:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ScopeExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>void</B> method() {
        {
            <FONT COLOR="blue"><B>region</B></FONT> OutOfScopeRegion;
            <FONT COLOR="fuchsia"><EM>// Scope ends here</EM></FONT>
        }
        <FONT COLOR="fuchsia"><EM>// Error:  OutOfScopeRegion is no longer in scope</EM></FONT>
        ScopeExample&lt;OutOfScopeRegion&gt; x = <B>null</B>;
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 2.3.4&nbsp;&nbsp;Commutative Methods-->

<H4 CLASS="subsubsection"><A NAME="htoc9">2.3.4</A>&nbsp;&nbsp;Commutative Methods<A NAME="sec:classes:methods:commutative"></A></H4><!--SEC END -->

<!--NAME classes.methods.commutative-->
<BR>
<BR>
The keyword <TT>commutative</TT> may appear as a method qualifier, before
the return type and before the type and/or region parameters of the
method, if any:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><B><FONT COLOR="blue">commutative</FONT> int</B> m(...) { ... }</TT></DIV><BR>
<BR>
The <TT>commutative</TT> qualifier is a programmer-specified guarantee
that any invocation of the method commutes with itself. It is
typically used for commutative operations on concurrent data
structures such as counter updates, set inserts, histograms, and
reductions. These operations write to shared data in a way that
&#8220;looks interfering&#8221; to the DPJ effect system, but due to the
semantics of the data structure (which the effect system does not know
about), still preserves determinism. For example, here is a use of
the <TT>commutative</TT> qualifier to write a simple counter class:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><B>class</B> Counter&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
  <B>private int</B> count <FONT COLOR="blue"><B>in</B></FONT> R;
  <B>void</B> clear() <FONT COLOR="blue"><B>writes</B></FONT> R { count = 0; }
  <B><FONT COLOR="blue">commutative</FONT> synchronized void</B> increment() <FONT COLOR="blue"><B>writes</B></FONT> R {
    ++count;
  }
  <B>int</B> getCount() <FONT COLOR="blue"><B>reads</B></FONT> R { <B>return</B> count; }
}</TT></DIV><BR>
<BR>
When a method <I>m</I> is labeled <TT>commutative</TT>, the DPJ compiler
treats the effects of multiple invocations of <I>m</I> as noninterfering,
even if the read and write effects by themselves, without the
<TT>commutative</TT>, would be interfering. For example, in the case of
the counter class, concurrent invocations of <TT>increment</TT> have
interfering writes to region <TT>R</TT>. However, the <TT>commutative</TT>
annotation tells the DPJ compiler to &#8220;ignore&#8221; that interference.
So, for example, the following code compiles with no errors or
warnings:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT>Counter&lt;Root&gt; counter = <B>new</B> Counter&lt;Root&gt;();
<FONT COLOR="blue"><B>foreach</B></FONT>(<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, 10)
  counter.increment();</TT></DIV><BR>
<BR>
Note that the <TT>commutative</TT> qualifier <EM>only</EM> tells the DPJ
compiler that it is safe to ignore interference. It does <EM>not</EM>
introduce any special synchronization or other concurrency control.
In particular, it is the programmer's responsibility when using
<TT>commutative</TT> to ensure two things:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
The method is properly synchronized so that concurrent accesses
 to the method behave as though they have occurred in sequence (i.e.,
 the accesses have <EM>serializable</EM> semantics). In the example
 above, this property is enforced by making method <TT>increment</TT>
 <TT>synchronized</TT>. Without the <TT>synchronized</TT> keyword,
 concurrent invocations of <TT>increment</TT> would have a
 read-modify-write race, and some of the updates could be lost.<BR>
<BR>
<LI CLASS="li-enumerate">The method behaves so that either order of a pair of invocations
 produces the same result. In the example above, this property holds
 because incrementing a counter twice, in either order, has the same
 result (i.e., the final counter value is 2 more than the starting
 value).
</OL>
Typically, in user code, the <TT>commutative</TT> annotation is used for
simple commutative read-modify-write operations like the one
illustrated above. More complicated operations, e.g. set or tree
inserts, where the commutativity property is more subtle to verify,
would typically be provided by library or framework code. Only very
skilled programmers should attempt to &#8220;roll their own&#8221;
implementation of such commutative operations, as the potential for
subtle bugs is high, and the DPJ effect system provides no assistance
in checking for such bugs.<BR>
<BR>
<!--TOC subsection 2.4&nbsp;&nbsp;Region Parameters-->

<H3 CLASS="subsection"><A NAME="htoc10">2.4</A>&nbsp;&nbsp;Region Parameters<A NAME="sec:classes:params"></A></H3><!--SEC END -->

<!--NAME classes.params.html-->
<BR>
<BR>
DPJ extends Java's generic type parameters by allowing <EM>region
 parameters</EM> in class and method definitions. Class region
parameters become bound to actual regions when the class is
instantiated to a type (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>). Method
region parameters become bound to actual regions when the method is
invoked (§&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A>).<BR>
<BR>
<!--TOC subsubsection 2.4.1&nbsp;&nbsp;Class Region Parameters-->

<H4 CLASS="subsubsection"><A NAME="htoc11">2.4.1</A>&nbsp;&nbsp;Class Region Parameters<A NAME="sec:classes:params:class"></A></H4><!--SEC END -->

<!--NAME classes.params.class.html-->
<BR>
<BR>
<B>Declaring class region parameters:</B> As in ordinary generic
Java, the class parameters are given as a comma-separated list of
identifiers enclosed in angle brackets (<TT>&lt;&gt;</TT>) immediately after
the class name. The new features are as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Both type and region parameters may appear. If both appear, all
 the region parameters must follow the type parameters.
<LI CLASS="li-itemize">The first region parameter <EM>must</EM> be preceded by the
 keyword <TT>region</TT>. Any of the other region parameters <EM>may</EM>
 be preceded by the keyword <TT>region</TT>.
<LI CLASS="li-itemize">Any of the type parameters <EM>may</EM> be preceded by the keyword
 <TT>type</TT>.
</UL>
The keyword <TT>type</TT> is provided for convenience in distinguishing
type from region parameters; but to preserve compatibility with
ordinary Java syntax, it is never required.<BR>
<BR>
For example, the following are valid class declarations:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Type parameter T</EM></FONT>
<B>class</B> A&lt;T&gt; {}
<B>class</B> B&lt;<FONT COLOR="blue"><B>type</B></FONT> T&gt; {}
<FONT COLOR="fuchsia"><EM>// Region parameter R</EM></FONT>
<B>class</B> C&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {}
<FONT COLOR="fuchsia"><EM>// Type parameter T, region parameter R</EM></FONT>
<B>class</B> D&lt;T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; {}
<B>class</B> E&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; {}
<FONT COLOR="fuchsia"><EM>// Type parameters T1, T2, region parameters R1, R2</EM></FONT>
<B>class</B> F&lt;<FONT COLOR="blue"><B>type</B></FONT> T1, T2, <FONT COLOR="blue"><B>region</B></FONT> R1, R2&gt; {}</TT></DIV><BR>
<BR>
<B>Using class region parameters:</B> A class region parameter is
available for use in RPLs (§&nbsp;<A HREF="#sec:rpls:param">3.3</A>) within the class
definition. In particular, a class region parameter standing alone is
a valid RPL. For example, the following code declares a class
<TT>ParamInField</TT> with a region parameter <TT>R</TT> and uses <TT>R</TT> in
a field RPL specifier (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>):

 <DIV CLASS="dpjlisting"><TT><B>class</B> ParamInField&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>public int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
}</TT></DIV>This code says that the region of field <TT>x</TT> of an object
instantiated from the <TT>ParamInField</TT> class is given by the RPL
provided as an argument to <TT>R</TT> in the type of the object. For
example, this code creates a fresh <TT>ParamInField</TT> object called
<TT>p</TT>, such that the field <TT>p.x</TT> is in region <TT>Root</TT>:

 <DIV CLASS="dpjlisting"><TT>ParamInField&lt;Root&gt; p = <B>new</B> ParamInField&lt;Root&gt;();</TT></DIV><BR>
<BR>
As another example of using parameters, the following code declares a
class region parameter <TT>R</TT> and uses it to instantiate a type
(§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>):

 <DIV CLASS="dpjlisting"><TT><B>class</B> ParamInType&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    ParamInType&lt;R&gt; x <FONT COLOR="blue"><B>in</B></FONT> R;
}</TT></DIV>And this code creates a fresh <TT>ParamInType</TT> object whose field
<TT>x</TT> has type <TT>ParamInType&lt;Root&gt;</TT>:

 <DIV CLASS="dpjlisting"><TT>ParamInType&lt;Root&gt; p = <B>new</B> ParamInType&lt;Root&gt;();</TT></DIV>This pattern is very useful for creating chains or graphs of objects,
all in the same region. For example, without the region parameter
<TT>R</TT>, there would be no way to get the object pointed to by <TT>x</TT>
in the same region as the parent object. The RPL specifier <TT>x in
 R</TT> is insufficient, because that says only that the field <TT>x</TT> is
in <TT>R</TT>, not the object that it points to. To get both the field
and the object in the same region, you have to write

 <DIV CLASS="dpjlisting"><TT>ParamInType&lt;R&gt; x <FONT COLOR="blue"><B>in</B></FONT> R</TT></DIV>as shown. Moreover, DPJ provides the flexibility to assign different
regions to the field pointing to the object and the object itself, for
example:

 <DIV CLASS="dpjlisting"><TT>ParamInType&lt;r1&gt; x <FONT COLOR="blue"><B>in</B></FONT> r2</TT></DIV>This allows for finer-grain partitioning of memory than if the field
and the object always had the same region.<BR>
<BR>
As in generic Java, a new declaration of a parameter named <TT>R</TT>
hides any parameter named <TT>R</TT> that is already in scope. For
example, the following two definitions of the class <TT>Hiding</TT> are
equivalent:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// First version</EM></FONT>
<B>class</B> Hiding&lt;<FONT COLOR="blue"><B>region</B></FONT> R1&gt; {
    <B>class</B> Inner&lt;<FONT COLOR="blue"><B>region</B></FONT> R2&gt; {
        Hiding&lt;R2&gt; x;
    }
}
<FONT COLOR="fuchsia"><EM>// Second version</EM></FONT>
<B>class</B> Hiding&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>class</B> Inner&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
        Hiding&lt;R&gt; x;
    }
}</TT></DIV>In both versions we are declaring a parameter for the outer class,
declaring a parameter for the inner class, and using the inner class
parameter to instantiate a type inside the inner class. In the first
version we have given distinct names to the two parameters; while in
the second version we have used the same name.<BR>
<BR>
Also as with Java generic type parameters, a class region parameter
may not be used in a static context. This is because DPJ region
information (like Java generic information) is <EM>erased</EM> during
the compilation process. In particular, only one set of code is
generated for all types instantiating a given class. If region
parameters could be used in a static context, then different code
would have to be generated for each different type (as with C++
templates).
For example, the following code is invalid, because it attemps to use
region <TT>R</TT> in a static context:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Outer&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>public static class</B> Inner {
        <FONT COLOR="fuchsia"><EM>// Not allowed!</EM></FONT>
        <B>public int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    }
}</TT></DIV><BR>
<BR>
Fortunately, this limitation is easy to work around. The standard way
(again, as with Java generics) is to introduce a new parameter for the
inner class, and write <TT>Inner&lt;R1&gt;</TT> to place <TT>x</TT> in region
<TT>R1</TT>:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><B>class</B> Outer&lt;<FONT COLOR="blue"><B>region</B></FONT> R1&gt; {
    <B>public static class</B> Inner&lt;<FONT COLOR="blue"><B>region</B></FONT> R2&gt; {
        <B>public int</B> x <FONT COLOR="blue"><B>in</B></FONT> R2;
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 2.4.2&nbsp;&nbsp;Method Region Parameters-->

<H4 CLASS="subsubsection"><A NAME="htoc12">2.4.2</A>&nbsp;&nbsp;Method Region Parameters<A NAME="sec:classes:params:method"></A></H4><!--SEC END -->

<!--NAME classes.params.method.html-->
<BR>
<BR>
<B>Declaring method region parameters:</B> As in ordinary generic
Java, the method region parameters are given as a comma-separated list
of identifiers enclosed in angle brackets (<TT>&lt;&gt;</TT>) immediately
before the method return type (for non-constructor methods) or class
name (for constructors). A method parameter declaration has the same
form as a class parameter declaration
(§&nbsp;<A HREF="#sec:classes:params:class">2.4.1</A>).
For example, the following code defines a method with type parameter
<TT>T</TT> and region parameter <TT>R</TT>:

 <DIV CLASS="dpjlisting"><TT><B>class</B> MethodParams {
    <B>public abstract</B> &lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; <B>void</B> method();
}</TT></DIV>As for class parameters, the <TT>type</TT> keyword is always optional,
and the <TT>region</TT> keyword is optional except as to the first region
parameter.<BR>
<BR>
<B>Using method region parameters:</B> A method region parameter is
available for use in RPLs (§&nbsp;<A HREF="#sec:rpls:param">3.3</A>) with the method
definition. In particular, a method region parameter standing alone
is a valid RPL. For example, the following code declares a method
<TT>method</TT> with a region parameter <TT>R</TT> and uses <TT>R</TT> in the
formal (value) parameter and return type of the method:

 <DIV CLASS="dpjlisting"><TT><B>class</B> MethodParamUses&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R1&gt;<B>void</B> method(MethodParamUses&lt;R1&gt; arg);
}</TT></DIV>As in generic Java, a new declaration of a parameter named <TT>R</TT>
hides any parameter named <TT>R</TT> that is already in scope. For
example, the following code is equivalent to the code above:

 <DIV CLASS="dpjlisting"><TT><B>class</B> MethodParamUses&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> method(MethodParamUses&lt;R&gt; arg);
}</TT></DIV><BR>
<BR>
<B>Invoking methods defined with region parameters:</B> To invoke a
method defined with region parameters, the programmer may always use
<EM>explicit RPL arguments</EM>. Depending on the compiler's ability to
infer the arguments, in some cases the programmer may alternatively
use <EM>inferred RPL arguments</EM>. In either case, the arguments must
obey any disjointness constraints on the method's region parameters
(§&nbsp;<A HREF="#sec:classes:params:disjoint">2.4.3</A>).<BR>
<BR>
<I>Explicit RPL arguments:</I> The programmer can always supply the
RPL arguments to the method region parameters explicitly, using an
extension of the Java syntax for generic method arguments. For this
form, as for Java generic methods, there must be an explicit selector
and a dot preceding the method name; and the arguments must appear in
angle brackets after the dot, and before the method name. For
example:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>this.&lt;</TT><EM>args</EM><TT>&gt;</TT><EM>meth-name</EM><TT>()</TT>
</DL>
Here <EM>args</EM> are type and/or RPL arguments (defined below), and
<EM>meth-name</EM> is the name of the method being invoked. Notice that
to invoke a method defined in the enclosing class with explicit RPL
arguments, <TT>this</TT> (or the class name, for a <TT>static</TT> method)
must be used as a selector.<BR>
<BR>
The new DPJ features are as follows:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Both type and region parameters may appear. The number of type
 and RPL arguments must exactly match the number of type and region
 parameters (so all type arguments come first, because that is true
 for the parameters).
<LI CLASS="li-itemize">The first region parameter <EM>must</EM> be preceded by the
 keyword <TT>region</TT>. Any of the other region parameters <EM>may</EM>
 be preceded by the keyword <TT>region</TT>.
<LI CLASS="li-itemize">Any of the type parameters <EM>may</EM> be preceded by the keyword
 <TT>type</TT>.
</UL>

The following code example illustrates the use of explicit RPL
arguments to a method invocation:

 <DIV CLASS="dpjlisting"><TT><B>abstract class</B> ExplicitArgs&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt;T invokedMethod(ExplicitArgs&lt;R&gt; param);
    ExplicitArgs&lt;Root&gt; invokingMethod() {
        ExplicitArgs&lt;Root&gt; arg = <B>new</B> ExplicitArgs&lt;Root&gt;();
        <B>return this</B>.&lt;ExplicitArgs&lt;Root&gt;,Root&gt;invokedMethod(arg);
    }
}</TT></DIV>The abstract method <TT>invokedMethod</TT> is generic in type <TT>T</TT> and
region <TT>R</TT>. It takes an <TT>ExplicitArgs&lt;R&gt;</TT> object as a value
argument and returns type <TT>T</TT>. In <TT>invokingMethod</TT>, we create
a new <TT>ExplicitArgs&lt;Root&gt;</TT> and pass it to <TT>invokedMethod</TT>. We
pass <TT>ExplicitArgs&lt;Root&gt;</TT> as the type argument to <TT>T</TT> and
<TT>Root</TT> as the RPL argument to <TT>R</TT>, using explicit RPL
arguments. Notice that the type of <TT>arg</TT> matches the type of
<TT>param</TT>, after substituting <TT>Root</TT> for <TT>R</TT> in <TT>param</TT>.
If the types did not match, there would be a compile error. See
§&nbsp;<A HREF="#sec:types:exp:invoke">4.3.3</A> for more information about how typing
works for method invocations in the presence of region parameters.<BR>
<BR>
Note that the keyword <TT>region</TT> must be present to identify the
first RPL argument in the list, unlike the case of RPL arguments to
classes (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>), where the <TT>region</TT>
keyword is optional. The reason for this rule is Java's method
overloading: because multiple methods can be declared with the same
name but different parameters, information about which arguments are
types and which are regions is not always available from the method
name, as it is from the class name.<BR>
<BR>
<I>Inferred RPL arguments:</I> As in generic Java, a method with
type and/or region parameters may be written without any explicit
generic arguments. In this case the compiler will attempt to infer
the type and/or region arguments from the types of the value arguments
supplied to the method. For example, the <TT>dpjc</TT> compiler accepts
the following code, because it is able to infer from the type
<TT>InferredArguments&lt;Root&gt;</TT> of <TT>arg</TT> that the argument to
<TT>R</TT> is <TT>Root</TT>:

 <DIV CLASS="dpjlisting"><TT><B>class</B> InferredArguments&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> callee(InferredArguments&lt;R&gt; param);
    <B>void</B> caller() {
        InferredArguments&lt;Root&gt; arg = <B>new</B> InferredArguments&lt;Root&gt;();
        callee(arg);
    }
}</TT></DIV>This code is equivalent to the following:

 <DIV CLASS="dpjlisting"><TT><B>class</B> InferredArguments&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> callee(InferredArguments&lt;R&gt; param);
    <B>void</B> caller() {
        InferredArguments&lt;Root&gt; arg = <B>new</B> InferredArguments&lt;Root&gt;();
        <B>this</B>.&lt;Root&gt;callee(arg);
    }
}</TT></DIV><BR>
<BR>
While the compiler can infer region arguments to methods in many
common cases, in some cases it cannot, either because the inference
algorithm is insufficiently powerful, or because the information is
simply not available from the types of the value parameters. The
compiler uses <TT>Root:*</TT> as the argument to any region parameters in
the method that it cannot infer. For example, the compiler would
infer <TT>Root:*</TT> as the argument to <TT>R</TT> in the following code:

 <DIV CLASS="dpjlisting"><TT><B>class</B> InferredArguments&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> callee() <FONT COLOR="blue"><B>writes</B></FONT> R;
    <B>void</B> caller() {
        <FONT COLOR="fuchsia"><EM>// There are no value arguments, so there is no way to infer
        // the argument to R!  This is equivalent to this.&lt;Root:*&gt;callee();</EM></FONT>
        callee();
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 2.4.3&nbsp;&nbsp;Disjointness Constraints-->

<H4 CLASS="subsubsection"><A NAME="htoc13">2.4.3</A>&nbsp;&nbsp;Disjointness Constraints<A NAME="sec:classes:params:disjoint"></A></H4><!--SEC END -->

<!--NAME classes.params.disjoint.html-->
<BR>
<BR>
It is sometimes necessary to require that two or more region
parameters (or a region parameter and some other region) be disjoint.
For example, the following code can have a data race unless regions
<TT>R1</TT> and <TT>R2</TT> are bound to disjoint regions:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Unsafe&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    &lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2&gt;<B>void</B> method(Unsafe&lt;R1&gt; o1, Unsafe&lt;R2&gt; o2) {
        <FONT COLOR="blue"><B>cobegin</B></FONT> {
            ++o1.x; <FONT COLOR="fuchsia"><EM>// writes R1</EM></FONT>
            ++o2.x; <FONT COLOR="fuchsia"><EM>// writes R2</EM></FONT>
        }
    }
}</TT></DIV>To support this reasoning, DPJ provides optional <EM>disjointness
 constraints</EM> for region parameters. If used, the constraints must
appear after the region parameters, and be separated from them by a
vertical bar:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>&lt;region R1, R2, ... |</TT> <EM>constraints</EM> <TT>&gt;</TT>
</DL>
<EM>constraints</EM> is a comma-separated list of constraints, where a
constraint has the form <EM>rpl1</EM> <TT>#</TT> <EM>rpl2</EM>, and
<EM>rpl1</EM> and <EM>rpl2</EM> are valid RPLs (§&nbsp;<A HREF="#sec:rpls">3</A>). The
constraint states that <EM>rpl1</EM> and <EM>rpl2</EM> are disjoint
regions (§&nbsp;<A HREF="#sec:rpls:comparing:disjoint">3.6.4</A>). For class region
parameters, the requirement is enforced when the class is instantiated
to a type by substituting RPLs for parameters
(§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>). For method region parameters, the
requirement is enforced when RPL arguments are provided to an
invocation of the method (§&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A>).<BR>
<BR>
For example, the code above could be rewritten as follows to make it
safe:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Safe&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    &lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2 | R1 # R2&gt; <B>void</B>(Safe&lt;R1&gt; o1, Safe&lt;R2&gt; o2) {
        <FONT COLOR="blue"><B>cobegin</B></FONT> {
            ++o1.x; <FONT COLOR="fuchsia"><EM>// writes R1</EM></FONT>
            ++o2.x; <FONT COLOR="fuchsia"><EM>// writes R2</EM></FONT>
        }
    }
}</TT></DIV>There is no interference between the statements of the <TT>cobegin</TT>,
because <TT>R1</TT> and <TT>R2</TT> are guaranteed to be disjoint regions.
Therefore, the effects of <TT>++o1.x</TT> and <TT>++o2.x</TT> are to
disjoint memory locations.<BR>
<BR>
We can also use constraints to make parameters disjoint from region
names, not just other parameters. For example, we can write the
following:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Safe2&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> r;
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    &lt;<FONT COLOR="blue"><B>region</B></FONT> R | R # r&gt;<B>void</B>(Safe2&lt;R&gt; o1, Safe2&lt;r&gt; o2) {
        <FONT COLOR="blue"><B>cobegin</B></FONT> {
            ++o1.x; <FONT COLOR="fuchsia"><EM>// writes R</EM></FONT>
            ++o2.x; <FONT COLOR="fuchsia"><EM>// writes r</EM></FONT>
        }
    }
}</TT></DIV>This technique is useful when methods need to operate disjointly in
parallel on global data and data passed in as an an argument. Of
course, the region of the global data could also be passed in as an
RPL argument, but using the global region directly in the constraint
saves writing parameters and arguments.<BR>
<BR>
It is an error to write a constraint that cannot be satisfied, because
the RPLs given cannot be disjoint. For instance, this class
declaration generates a compile error:

 <DIV CLASS="dpjlisting"><TT><B>class</B> BadConstraint&lt;<FONT COLOR="blue"><B>region</B></FONT> R | R # R&gt; {}</TT></DIV><BR>
<BR>
It is also an error to provide RPL arguments to a class or method that
do not satisfy the constraints. For example:

 <DIV CLASS="dpjlisting"><TT><B>abstract class</B> BadArgs&lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2 | R1 # R2&gt; {
    <FONT COLOR="fuchsia"><EM>// Error:  Instantiating BadArgs with R1=Root, R2=Root</EM></FONT>
    BadArgs&lt;Root, Root&gt; x;
    <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R3, R4 | R3 # R4&gt;<B>void</B> callee();
    <FONT COLOR="fuchsia"><EM>// Error:  Invoking callee with R3=Root, R4=Root</EM></FONT>
    <B>void</B> caller() {
        <B>this</B>.&lt;Root,Root&gt;callee();
    }
}</TT></DIV><TT>BadArgs&lt;Root, Root&gt;</TT> is an invalid type, because the RPLs
supplied as arguments to <TT>R1</TT> and <TT>R2</TT> are not disjoint, as
required by the definition of class <TT>BadArgs</TT>. Similarly,
<TT>this.&lt;Root,Root&gt;callee()</TT> is an invalid invocation of
<TT>callee</TT>, because the RPLs supplied as arguments to <TT>R3</TT> and
<TT>R4</TT> are not disjoint, as required by the definition of method
<TT>callee</TT>.<BR>
<BR>

<!--TOC section 3&nbsp;&nbsp;Region Path Lists (RPLs)-->

<H2 CLASS="section"><A NAME="htoc14">3</A>&nbsp;&nbsp;Region Path Lists (RPLs)<A NAME="sec:rpls"></A></H2><!--SEC END -->

<!--NAME rpls.html-->
<BR>
<BR>
This section describes <EM>region path lists</EM>, or RPLs. RPLs are
the fundamental tool for describing sets of memory locations in DPJ.
RPLs can be <EM>fully specified</EM> or <EM>partially specified</EM>. A
fully-specified RPL names a <EM>region</EM>, which represents a set of
memory locations on the heap. The correspondence between memory
locations and regions is given by the way that the programmer has
assigned RPLs to class fields (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>)
and bound RPLs to region parameters in class types
(§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>), array types
(§&nbsp;<A HREF="#sec:types:array:instant">4.2.1</A>), and method invocations
(§&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A>). A partially-specified RPL names
a <EM>set of regions</EM> and is useful for expressing hierarchical
effects (e.g., &#8220;all regions under this one&#8221;).<BR>
<BR>
RPLs are naturally nested. In fact the motivation for name &#8220;region
path list&#8221; is that an RPL is a sequence of names that describes a
path from the root in a tree of regions. Together with partially
specified RPLs, this nesting structure provides a great deal of power
in comparing sets of memory locations to determine whether they are
overlapping or disjoint. These properties are the key to specifying
and checking effects. In particular, checking <EM>subeffects</EM>
(e.g., that a method's effect summary covers its effects,
§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>) requires reasoning about
inclusion of RPLs, while checking <EM>noninterfering effects</EM> (e.g.,
that the branches of a <TT>cobegin</TT> statement do not interfere,
§&nbsp;<A HREF="#sec:parallel:cobegin">6.1</A>) requires reasoning about disjointness
of RPLs.<BR>
<BR>
The rest of this section proceeds as follows. §&nbsp;<A HREF="#sec:rpls:basic">3.1</A>
describes the simplest form of RPL, which is just a name, such as a
region name declared at class scope
(§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>). §&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>
describes how to construct RPLs using <EM>sequences of names</EM>, which
put a nesting structure on RPLs. §&nbsp;<A HREF="#sec:rpls:param">3.3</A> describes
the use of region parameters (§&nbsp;<A HREF="#sec:classes:params">2.4</A>) with RPLs.
These parameters allow RPLs to vary with the class type or method
invocation. §&nbsp;<A HREF="#sec:rpls:partial">3.4</A> explains how to write
<EM>partially specified RPLs</EM>, which describe sets of fully
specified RPLs. §&nbsp;<A HREF="#sec:rpls:comparing">3.6</A> explains the rules for
comparing RPLs for properties such as inclusion and disjointness.<BR>
<BR>
Finally, a word about the uses of RPLs. This section is about the
<EM>definition</EM> of RPLs, and the relations among them (inclusion,
disjointness, etc.). The various ways in which RPLs can be
<EM>used</EM> (i.e., how they actually appear in a DPJ program) are
covered in other sections. To provide context for this section, we
list all the possible uses here, together with the sections discussing
those uses:
<UL CLASS="itemize"><LI CLASS="li-itemize">
RPLs can appear in field RPL specifiers, to assign class fields
 to regions (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>).
<LI CLASS="li-itemize">RPLs can appear in effect summaries
 (§&nbsp;<A HREF="#sec:effects:summaries">5.2</A>). These RPLs describe the effects
 of a code statement.
<LI CLASS="li-itemize">RPLs can appear as arguments to parametric class types
 (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>) and to array types
 (§&nbsp;<A HREF="#sec:types:array:instant">4.2.1</A>). These RPLs provide actual
 regions for the parameters in the instantiation of a class or array.
<LI CLASS="li-itemize">RPLs can appear in method invocations, as arguments to method
 region parameters (§&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A>). These RPLs
 provide actual regions for the parameters in an invocation of a
 method.
</UL>
Throughout this section, we provide example uses to illustrate the
definitions in context.<BR>
<BR>
<!--TOC subsection 3.1&nbsp;&nbsp;Basic Region Names-->

<H3 CLASS="subsection"><A NAME="htoc15">3.1</A>&nbsp;&nbsp;Basic Region Names<A NAME="sec:rpls:basic"></A></H3><!--SEC END -->

<!--NAME rpls.basic.html-->
<BR>
<BR>
This section describes the simplest form of RPL, which is a single
name. There are five kinds of region names: 
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Root</TT>, a special name that is always in scope.
<LI CLASS="li-enumerate">A region name declared at class scope
 (§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>).
<LI CLASS="li-enumerate">An array index region <TT>[</TT><EM>exp</EM><TT>]</TT>, where <EM>exp</EM>
 is an integer expression.
<LI CLASS="li-enumerate">A region name declared in a method-local scope
 (§&nbsp;<A HREF="#sec:classes:methods:local-regions">2.3.3</A>).
<LI CLASS="li-enumerate">A <TT>final</TT> local variable or <TT>this</TT>. 
</OL>
The first three kinds of names are available everywhere (except that
class region names may have access qualifiers, see
§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>). The last two kinds of names are
available only in the scope where the region names or variables
are active.<BR>
<BR>
<!--TOC subsubsection 3.1.1&nbsp;&nbsp;The Name <TT>Root</TT>-->

<H4 CLASS="subsubsection"><A NAME="htoc16">3.1.1</A>&nbsp;&nbsp;The Name <TT>Root</TT><A NAME="sec:rpls:basic:root"></A></H4><!--SEC END -->

<!--NAME rpls.basic.root.html-->
<BR>
<BR>
The region name <TT>Root</TT> is always in scope, and can be used
anywhere as an RPL. For example, the following code uses <TT>Root</TT>
in a field region specifier (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>)
and to instantiate a class type (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>):

 <DIV CLASS="dpjlisting"><TT><B>class</B> RootExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    RootExample&lt;Root&gt; x <FONT COLOR="blue"><B>in</B></FONT> Root;
}</TT></DIV><BR>
<BR>
The name <TT>Root</TT> has a special meaning: it is the root of the
region tree. Every RPL is nested under <TT>Root</TT>. For more
information about the nesting relation on RPLs, see
§&nbsp;<A HREF="#sec:rpls:comparing:nest">3.6.2</A>.<BR>
<BR>
<!--TOC subsubsection 3.1.2&nbsp;&nbsp;Class Region Names-->

<H4 CLASS="subsubsection"><A NAME="htoc17">3.1.2</A>&nbsp;&nbsp;Class Region Names<A NAME="sec:rpls:basic:class"></A></H4><!--SEC END -->

<!--NAME rpls.basic.class.html-->
<BR>
<BR>
A region name declared as a class member
(§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>) is available for use as an RPL in
any scope where it is visible. For example, the following code
declares a region name <TT>ClassRegion</TT> at class scope, then uses it
in a field region specifier (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>)
and to instantiate a class type (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>):

 <DIV CLASS="dpjlisting"><TT><B>class</B> ClassRegionExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> ClassRegion;
    <B>int</B> ClassRegionExample&lt;ClassRegion&gt; x <FONT COLOR="blue"><B>in</B></FONT> ClassRegion;
}</TT></DIV>Because class region names can be package- and class-qualified, like
Java static fields, the following code is also legal:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Class1 {
    <FONT COLOR="blue"><B>region</B></FONT> ClassRegion;
}
<B>class</B> Class2 {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> Class1.ClassRegion;
}</TT></DIV><BR>
<BR>
When a class region name <I>R</I> is used as an RPL, it is shorthand for
the name sequence <TT>Root</TT>:<I>R</I>, as described in
§&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>. For example, the following definition of
<TT>Class2</TT> is equivalent to the one given above:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Class2 {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> Root:Class1.ClassRegion;
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 3.1.3&nbsp;&nbsp;Array Index RPLs-->

<H4 CLASS="subsubsection"><A NAME="htoc18">3.1.3</A>&nbsp;&nbsp;Array Index RPLs<A NAME="sec:rpls:basic:array"></A></H4><!--SEC END -->

<!--NAME rpls.basic.array.html-->
<BR>
<BR>
The name <TT>[</TT><I>e</I><TT>]</TT>, where <I>e</I> is an integer expression,
functions as an RPL, called an <EM>array index RPL</EM>. The array
index RPL represents a region indexed by the number that <I>e</I>
evaluates to at runtime (so there is a different region for each
natural number). It is useful in conjunction with
<EM>index-parameterized arrays</EM> (§&nbsp;<A HREF="#sec:types:array:ipa">4.2.2</A>) and
with DPJ's built-in features for array partitioning
(§&nbsp;<A HREF="#sec:runtime:partition">7.2</A>).<BR>
<BR>
As with class region names used as RPLs
(§&nbsp;<A HREF="#sec:rpls:basic:class">3.1.2</A>), an array index RPL <TT>[</TT><I>e</I><TT>]</TT>
is short for <TT>Root:[</TT><I>e</I><TT>]</TT>.<BR>
<BR>
<!--TOC subsubsection 3.1.4&nbsp;&nbsp;Local Region Names-->

<H4 CLASS="subsubsection"><A NAME="htoc19">3.1.4</A>&nbsp;&nbsp;Local Region Names<A NAME="sec:rpls:basic:local"></A></H4><!--SEC END -->

<!--NAME rpls.basic.local.html-->
<BR>
<BR>
A region name declared inside a method body
(§&nbsp;<A HREF="#sec:classes:methods:local-regions">2.3.3</A>) is available for use as
an RPL in the scope where it is visible. For example, the following
code declares a region name <TT>LocalRegion</TT> in a local scope, and
uses it to instantiate a type:

 <DIV CLASS="dpjlisting"><TT><B>class</B> LocalRegionExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>void</B> method() {
        <FONT COLOR="blue"><B>region</B></FONT> LocalRegion;
        LocalRegionExample&lt;LocalRegion&gt; lre =
          <B>new</B> LocalRegionExample&lt;LocalRegion&gt;();
    }
}</TT></DIV><BR>
<BR>
As with class region names and array index regions, an RPL consisting
of a single local region name implicitly starts with <TT>Root</TT>. For
example, the class definition above is equivalent to the following:

 <DIV CLASS="dpjlisting"><TT><B>class</B> LocalRegionExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>void</B> method() {
        <FONT COLOR="blue"><B>region</B></FONT> LocalRegion;
        LocalRegionExample&lt;Root:LocalRegion&gt; lre =
          <B>new</B> LocalRegionExample&lt;Root:LocalRegion&gt;();
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 3.1.5&nbsp;&nbsp;<TT>final</TT> Local Variables and <TT>this</TT> as Region Names-->

<H4 CLASS="subsubsection"><A NAME="htoc20">3.1.5</A>&nbsp;&nbsp;<TT>final</TT> Local Variables and <TT>this</TT> as Region Names<A NAME="sec:rpls:basic:var"></A></H4><!--SEC END -->

<!--NAME rpls.basic.var.html-->
<BR>
<BR>
The following variables may be used as an RPL:
<UL CLASS="itemize"><LI CLASS="li-itemize">
A <TT>final</TT> local variable or method parameter with a class
 type.
<LI CLASS="li-itemize">The variable <TT>this</TT>, in a non-static context.
</UL>
This usage is called a <EM>variable RPL</EM>. For example, the
following code uses <TT>this</TT> as an RPL in a field region specifier
(§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>), as an argument to a class
type (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>), and in an effect summary
(§&nbsp;<A HREF="#sec:effects:summaries">5.2</A>):

 <DIV CLASS="dpjlisting"><TT><B>class</B> VarRegionExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    VarRegionExample&lt;<B>this</B>&gt; x <B><FONT COLOR="blue">in</FONT> this</B>;
    <B>void</B> setX(VarRegionExample&lt;<B>this</B>&gt; x) <B><FONT COLOR="blue">writes</FONT> this</B> {
        <B>this</B>.x = x;
    }
}</TT></DIV><BR>
<BR>
Variable RPLs allow <EM>runtime objects to function as regions</EM>, as
in type systems based on <EM>ownership</EM>. The variable stands in for
the object stored to the variable at runtime. Because the variable
must be <TT>final</TT> or <TT>this</TT> (which cannot be assigned to), the
variable always refers to the same object. This feature is
particularly useful in conjunction with the <TT>DPJParititon</TT> class
(§&nbsp;<A HREF="#sec:runtime:partition">7.2</A>), because it provides a way to
instantiate a partition with the region corresponding to the array
being partitioned.<BR>
<BR>
As in ownership systems, a variable RPL is nested under the first RPL
argument of its type, which is called the <EM>owner RPL</EM> of the type
(§&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>). For example, in the code above,
the variable <TT>this</TT> has type <TT>VarRegionExample&lt;R&gt;</TT>, so it is
nested under the RPL <TT>R</TT>. For more information about the nesting
relationship on RPLs, see §&nbsp;<A HREF="#sec:rpls:comparing:nest">3.6.2</A>.<BR>
<BR>
<!--TOC subsection 3.2&nbsp;&nbsp;Sequences of Basic Names-->

<H3 CLASS="subsection"><A NAME="htoc21">3.2</A>&nbsp;&nbsp;Sequences of Basic Names<A NAME="sec:rpls:sequences"></A></H3><!--SEC END -->

<!--NAME rpls.sequences.html-->
<BR>
<BR>
RPLs are built up from colon-separated sequences of names; this gives
them a natural nesting structure. For example, if <TT>A</TT> and <TT>B</TT>
are names, then <TT>A</TT>, <TT>B</TT>, <TT>A:B</TT>, <TT>B:A</TT>, <TT>A:A:B</TT>,
and so forth are all RPLs. The nesting structure is given by the
syntax: for example, <TT>A:B</TT> and <TT>A:A:B</TT> are both nested under
<TT>A</TT>. Note that nesting does not imply inclusion; <TT>A</TT> and
<TT>A:B</TT> are distinct regions. In particular the effect <TT>writes
 A</TT> does <EM>not</EM> cover (or imply) the effect <TT>writes A:B</TT>.
However, the nesting structure creates a hierarchy of regions that is
useful in conjunction with partially specified RPLs
(§&nbsp;<A HREF="#sec:rpls:partial">3.4</A>), because then we can use it to say things
like &#8220;all RPLs under this one&#8221; or &#8220;all RPLs under this one that end
in <TT>B</TT>.&#8221; Separating nesting from inclusion like this makes RPLs
more complicated, but it also allows greater precision.<BR>
<BR>
An RPL is valid if it is conforms to the following rules:
<UL CLASS="itemize"><LI CLASS="li-itemize">
It is composed of basic names (§&nbsp;<A HREF="#sec:rpls:basic">3.1</A>),
 separated by colons.
<LI CLASS="li-itemize">If <TT>Root</TT> (§&nbsp;<A HREF="#sec:rpls:basic:root">3.1.1</A>) or a variable name
 (§&nbsp;<A HREF="#sec:rpls:basic:var">3.1.5</A>) appears in the sequence, it must
 appear first (so, in particular, both cannot appear).
</UL>
The names in the sequence are called the <EM>elements</EM> of the RPL.
If an RPL does not start with <TT>Root</TT> or a variable element, then
it is treated as implicitly starting with <TT>Root</TT>. For example,
<TT>A</TT> is the same as <TT>Root:A</TT>, and <TT>[0]</TT> is the same as
<TT>Root:[0]</TT>.<BR>
<BR>
The following are examples of valid RPLs, assuming that <TT>A</TT> and
<TT>B</TT> are declared region names in scope:

 <DIV CLASS="dpjlisting"><TT>A        <FONT COLOR="fuchsia"><EM>// Declared name</EM></FONT>
Root:A   <FONT COLOR="fuchsia"><EM>// Same as A</EM></FONT>
A:B      <FONT COLOR="fuchsia"><EM>// Sequence of names</EM></FONT>
Root:A:B <FONT COLOR="fuchsia"><EM>// Same as A:B</EM></FONT>
[0]      <FONT COLOR="fuchsia"><EM>// Array index region</EM></FONT>
Root:[0] <FONT COLOR="fuchsia"><EM>// Same as [0]</EM></FONT>
<B>this</B>     <FONT COLOR="fuchsia"><EM>// Variable region</EM></FONT>
<B>this</B>:A   <FONT COLOR="fuchsia"><EM>// Variable region with A appended</EM></FONT></TT></DIV><BR>
<BR>
The following are examples of RPLs that are <EM>not</EM> valid, because
they do not conform to the rules above:

 <DIV CLASS="dpjlisting"><TT>A:Root    <FONT COLOR="fuchsia"><EM>// Root must appear first</EM></FONT>
<B>this</B>:Root <FONT COLOR="fuchsia"><EM>// Root must appear first</EM></FONT>
A:<B>this</B>    <FONT COLOR="fuchsia"><EM>// this must appear first</EM></FONT>
Root:<B>this</B> <FONT COLOR="fuchsia"><EM>// this must appear first</EM></FONT></TT></DIV><BR>
<BR>
<!--TOC subsection 3.3&nbsp;&nbsp;Parameterized RPLs-->

<H3 CLASS="subsection"><A NAME="htoc22">3.3</A>&nbsp;&nbsp;Parameterized RPLs<A NAME="sec:rpls:param"></A></H3><!--SEC END -->

<!--NAME rpls.param.html-->
<BR>
<BR>
Class and method region parameters (§&nbsp;<A HREF="#sec:classes:params">2.4</A>) work
with RPLs in a natural way. First, a region parameter standing alone
is always a valid RPL, as shown in the examples in
§§&nbsp;<A HREF="#sec:classes:params:class">2.4.1</A>
and&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A>. Second, an RPL may be
constructed from a region parameter followed by a colon-separated
sequence of elements, similar to a sequence of basic names
(§&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>). If a parameter appears in an RPL, then
it must appear first, and no <TT>Root</TT> or <TT>final</TT> local variable
may appear in the RPL (because those, when they appear, must also be
first).<BR>
<BR>
The following are examples of valid parameterized RPLs, assuming that
<TT>R</TT> is a region parameter in scope and <TT>A</TT> and <TT>B</TT> are
declared region names in scope:

 <DIV CLASS="dpjlisting"><TT>R      <FONT COLOR="fuchsia"><EM>// Region parameter alone</EM></FONT>
R:A    <FONT COLOR="fuchsia"><EM>// Region parameter with name appended</EM></FONT>
R:A:B  <FONT COLOR="fuchsia"><EM>// Region parameter with names appended</EM></FONT>
R:[0]  <FONT COLOR="fuchsia"><EM>// Region parameter with index appended</EM></FONT></TT></DIV><BR>
<BR>
The following are examples of RPLs that are <EM>not</EM> valid, because
they do not conform to the rules above:

 <DIV CLASS="dpjlisting"><TT>A:R      <FONT COLOR="fuchsia"><EM>// R must appear first</EM></FONT>
Root:R   <FONT COLOR="fuchsia"><EM>// R must appear first</EM></FONT>
R:Root   <FONT COLOR="fuchsia"><EM>// Root must appear first</EM></FONT>
R:<B>this</B>   <FONT COLOR="fuchsia"><EM>// this must appear first</EM></FONT></TT></DIV><BR>
<BR>
The meaning of a parameterized RPL is that at runtime, the parameter
will be substituted away, generating a region that has <TT>Root</TT> or
an object as its first element. For example, consider the following
class definition:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ParameterExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> r;
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R:r
}</TT></DIV>The class <TT>ParameterExample</TT> has one region parameter <TT>R</TT>, and
one field <TT>x</TT> placed in RPL <TT>R</TT> using a field RPL specifier
(§&nbsp;<A HREF="#sec:classes:region-names">2.1</A>). Suppose we now instantiate that
class to a type (§&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A>), by binding
<TT>Root</TT> to <TT>R</TT>:

 <DIV CLASS="dpjlisting"><TT>ParameterExample&lt;Root&gt; pa = <B>new</B> ParameterExample&lt;Root&gt;();</TT></DIV>This type says that the object bound to <TT>pa</TT> at runtime has its
field <TT>x</TT> in RPL <TT>Root:r</TT> (substituting <TT>Root</TT> for <TT>R</TT>
in <TT>R:r</TT>). For more information about how this subsitution works,
see §&nbsp;<A HREF="#sec:types:exp">4.3</A>.<BR>
<BR>
<!--TOC subsection 3.4&nbsp;&nbsp;Partially Specified RPLs-->

<H3 CLASS="subsection"><A NAME="htoc23">3.4</A>&nbsp;&nbsp;Partially Specified RPLs<A NAME="sec:rpls:partial"></A></H3><!--SEC END -->

<!--NAME rpls.partial.html-->
<BR>
<BR>
In order for the nested structure of RPLs to be useful, the programmer
must be able to name a <EM>set</EM> of RPLs such as &#8220;all RPLs nested
under this one.&#8221; To support this kind of naming, DPJ has a special
element <TT>*</TT> that stands in for any sequence of RPL elements.
There is also a wildcard array index element <TT>[?]</TT>, where the
<TT>?</TT> stands in for any natural number. This is useful for naming
sets of array regions.<BR>
<BR>
<!--TOC subsubsection 3.4.1&nbsp;&nbsp;The <TT>*</TT> RPL Element-->

<H4 CLASS="subsubsection"><A NAME="htoc24">3.4.1</A>&nbsp;&nbsp;The <TT>*</TT> RPL Element<A NAME="sec:rpls:partial:star"></A></H4><!--SEC END -->

<!--NAME rpls.partial.star.html-->
<BR>
<BR>
An RPL may be written with <TT>*</TT> as one if its elements. The RPL
must otherwise follow the rules in §§&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>
and&nbsp;<A HREF="#sec:rpls:param">3.3</A>: for example, if a parameter appears in the
RPL, it must be first. It is permissible for an RPL to start with
<TT>*</TT>; in this case, there is an implicit <TT>Root</TT> before the
<TT>*</TT>. In particular, the RPL <TT>*</TT> is equivalent to <TT>Root:*</TT>
and refers to all regions.<BR>
<BR>
The meaning of an RPL containing <TT>*</TT> is that it stands in for all
legal RPLs that could be constructed by substituting sequences of zero
or more elements for the <TT>*</TT>. For example, <TT>A:*:B</TT> stands in
for <TT>A:B</TT>, <TT>A:A:B</TT>, <TT>A:B:B</TT>, <TT>A:A:A:B</TT>, etc. However,
<TT>A:*:B</TT> does <EM>not</EM> stand in for <TT>A:Root:B</TT>, because that
is not a valid RPL (<TT>Root</TT> must appear first). See
§§&nbsp;<A HREF="#sec:rpls:comparing:nest">3.6.2</A>
and&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A> for more information about the
nesting and inclusion rules for RPLs using <TT>*</TT>.<BR>
<BR>
Here are some examples of valid RPLs constructed with the <TT>*</TT>
element, assuming that <TT>A</TT> and <TT>B</TT> are declared region names
in scope:

 <DIV CLASS="dpjlisting"><TT>*          <FONT COLOR="fuchsia"><EM>// All RPLs</EM></FONT>
Root:*     <FONT COLOR="fuchsia"><EM>// Same as *</EM></FONT>
*:A        <FONT COLOR="fuchsia"><EM>// All RPLs under Root ending in A</EM></FONT>
A:*        <FONT COLOR="fuchsia"><EM>// All RPLs under Root:A</EM></FONT>
Root:A:*   <FONT COLOR="fuchsia"><EM>// Same as A:*</EM></FONT>
<B>this</B>:*     <FONT COLOR="fuchsia"><EM>// All RPLs under this</EM></FONT>
<B>this</B>:*:A   <FONT COLOR="fuchsia"><EM>// All RPLs under this ending in A</EM></FONT></TT></DIV>Although more complex RPLs are possible, typically in user code at
most one <TT>*</TT> appears in an RPL, as shown in the examples above.<BR>
<BR>
Here are some examples of RPLs that are <EM>not</EM> valid, because they
do not conform to the rules stated in §§&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>
and&nbsp;<A HREF="#sec:rpls:param">3.3</A> (<TT>R</TT> is a region parameter):

 <DIV CLASS="dpjlisting"><TT>*:R        <FONT COLOR="fuchsia"><EM>// R must appear first</EM></FONT>
*:<B>this</B>     <FONT COLOR="fuchsia"><EM>// this must appear first</EM></FONT>
A:*:Root   <FONT COLOR="fuchsia"><EM>// Root must appear first</EM></FONT></TT></DIV><BR>
<BR>
<!--TOC subsubsection 3.4.2&nbsp;&nbsp;The <TT>[?]</TT> RPL Element-->

<H4 CLASS="subsubsection"><A NAME="htoc25">3.4.2</A>&nbsp;&nbsp;The <TT>[?]</TT> RPL Element<A NAME="sec:rpls:partial:qmark"></A></H4><!--SEC END -->

<!--NAME rpls.partial.qmark.html-->
<BR>
<BR>
The <EM>wildcard array index element</EM> <TT>[?]</TT> may be used in an
RPL anywhere that an array index element <TT>[<I>e</I>]</TT> may appear
(§&nbsp;<A HREF="#sec:rpls:basic:array">3.1.3</A>). It stands in for any array index
element. For example:

 <DIV CLASS="dpjlisting"><TT>[?]        <FONT COLOR="fuchsia"><EM>// Matches [e] for any [e]</EM></FONT>
Root:[?]   <FONT COLOR="fuchsia"><EM>// Same as [?]</EM></FONT>
[?]:A      <FONT COLOR="fuchsia"><EM>// Matches [e]:A for any e</EM></FONT>
<B>this</B>:[?]   <FONT COLOR="fuchsia"><EM>// Matches this:[e] for any e</EM></FONT></TT></DIV><BR>
<BR>
<!--TOC subsection 3.5&nbsp;&nbsp;Local RPLs-->

<H3 CLASS="subsection"><A NAME="htoc26">3.5</A>&nbsp;&nbsp;Local RPLs<A NAME="sec:rpls:local"></A></H3><!--SEC END -->

<!--NAME rpls.local.html-->
<BR>
<BR>
A <EM>local RPL</EM> is an RPL that contains a local region name
(§&nbsp;<A HREF="#sec:rpls:basic:local">3.1.4</A>) as an element. It may be
parameterized and/or partially specified. For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> LocalRPLs&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> ClassRegion;
    <B>void</B> method() {
        <FONT COLOR="blue"><B>region</B></FONT> LocalRegion;
        <FONT COLOR="fuchsia"><EM>// LocalRegion is a local RPL; it is equivalent 
        // to Root:LocalRegion</EM></FONT>
        LocalRPLs&lt;LocalRegion&gt; x = <B>null</B>;
        <FONT COLOR="fuchsia"><EM>// R:LocalRegion:* is a local RPL</EM></FONT>
        LocalRpls&lt;ClassRegion:LocalRegion:*&gt; y = <B>null</B>;
        <FONT COLOR="fuchsia"><EM>// ClassRegion is not a local RPL</EM></FONT>
        LocalRpls&lt;ClassRegion&gt; z = <B>null</B>;
    }
}</TT></DIV>Local RPLs are important because they define <EM>local effects</EM>
(§&nbsp;<A HREF="#sec:effects:local">5.3</A>). A local effect is visible only in a
method and its callees, so doesn't have to be reported to the caller.
For example, in the code above, any effects on <TT>LocalRegion</TT> or
<TT>R:LocalRegion</TT> could be omitted from the effect summary of
<TT>method</TT>.<BR>
<BR>
<!--TOC subsection 3.6&nbsp;&nbsp;Comparing RPLs-->

<H3 CLASS="subsection"><A NAME="htoc27">3.6</A>&nbsp;&nbsp;Comparing RPLs<A NAME="sec:rpls:comparing"></A></H3><!--SEC END -->

<!--NAME rpls.comparing.html-->
<BR>
<BR>
To reason about effects, both the programmer and the compiler have to
make judgments like &#8220;this RPL is included in that one&#8221; or &#8220;this RPL
is disjoint from that one&#8221; (where &#8220;disjoint&#8221; means that the
corresponding sets of memory locations are nonintersecting). The
programmer has to do this in order to reason about which code sections
may be run in parallel safely, i.e., without interference. And the
compiler has to do it to check that the programmer got it right.<BR>
<BR>
To support this kind of reasoning, there are four relations on RPLs:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<EM>Equivalence</EM>, meaning that two RPLs refer to the same set
 of regions.
<LI CLASS="li-enumerate"><EM>Nesting</EM>, meaning that one RPL is a descendant of another
 in the region tree. For example, <TT>A:B</TT> is nested under <TT>A</TT>.
<LI CLASS="li-enumerate"><EM>Inclusion</EM>, meaning that the set of memory locations
 represented by one RPL includes the set of locations represented by
 another. For example, <TT>A:B</TT> is included in <TT>A:*</TT>. Note
 that <EM><TT>A:B</TT> is not included in <TT>A</TT></EM>. The <TT>*</TT> is
 necessary to get the inclusion. This is to increase the precision
 of effect specifications with RPLs.
<LI CLASS="li-enumerate"><EM>Disjointness</EM>, meaning that the set of memory locations
 represented by one RPL has no common elements with the set of memory
 locations represented by another RPL. For example, if <TT>A</TT> and
 <TT>B</TT> are distinct names, then they represent disjoint regions.
 Or <TT>R1</TT> and <TT>R2</TT> are disjoint if they are parameters
 declared to be disjoint (§&nbsp;<A HREF="#sec:classes:params:disjoint">2.4.3</A>).
</OL>
<!--TOC subsubsection 3.6.1&nbsp;&nbsp;Equivalence-->

<H4 CLASS="subsubsection"><A NAME="htoc28">3.6.1</A>&nbsp;&nbsp;Equivalence<A NAME="sec:rpls:comparing:equiv"></A></H4><!--SEC END -->

<!--NAME rpls.comparing.equiv-->
<BR>
<BR>
<B>Equivalent RPLs:</B> The meaning of the equivalence relation on
RPLs is that the sets of regions represented by the RPLs are the same.
Two RPLs are equivalent if they have the same number of elements, and
the corresponding pairs of elements are equivalent, as defined below.
This test is done after adding the implicit <TT>Root</TT> to the front of
RPLs that begin with a declared name element, array index element,
<TT>*</TT>, or <TT>[?]</TT>.<BR>
<BR>
For example, the following pairs of RPLs are equivalent:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Root:A</TT> and <TT>A</TT>
<LI CLASS="li-itemize"><TT>this:[i]</TT> and <TT>this:[i]</TT>, if <TT>i</TT> is a <TT>final</TT>
 local variable or method parameter
<LI CLASS="li-itemize"><TT>R:[i+1]</TT> and <TT>R:[i+1]</TT>, if <TT>i</TT> is a
<TT>final</TT> local variable or method parameter
</UL>
The following pairs of RPLs are not equivalent:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Root:A</TT> and <TT>Root:A:B</TT>
<LI CLASS="li-itemize"><TT>this:[i]</TT> and <TT>this:[i]</TT>, if <TT>i</TT> is not a
 <TT>final</TT> local variable or method parameter
<LI CLASS="li-itemize"><TT>this:[i]</TT> and <TT>this:[j]</TT>
<LI CLASS="li-itemize"><TT>R:[i+1]</TT> and <TT>R:[i+1]</TT>, if <TT>i</TT> is not a <TT>final</TT>
 local variable or method parameter
<LI CLASS="li-itemize"><TT>R:[i+1]</TT> and <TT>R:[i+2]</TT>
</UL>
<B>Equivalent RPL elements:</B> The following rules govern
equivalence of RPL elements.<BR>
<BR>
<I>Basic names other than array index elements:</I> Two RPL elements
are equivalent if they refer to the same basic name
(§&nbsp;<A HREF="#sec:rpls:basic">3.1</A>), except for array index elements.<BR>
<BR>
<I>The elements <TT>*</TT> and <TT>[?]</TT>:</I> Two RPL elements are
equivalent if they are both <TT>*</TT> or <TT>[?]</TT>.<BR>
<BR>
<I>Array index elements:</I> Two array index elements <TT>[<I>e</I><SUB>1</SUB>]</TT>
and <TT>[<I>e</I><SUB>2</SUB>]</TT> equivalent if <I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> always evaluate to the
same value (i.e., are &#8220;always equal&#8221;).<BR>
<BR>
Since the compiler can't always know when two expressions evaluate to
the same value, it applies the following conservative rules to
identify pairs of always-equal expressions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> are always-equal if they refer to the same
 compile-time integer constant.
<LI CLASS="li-itemize"><I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> are always-equal if they are the same local
 variable or method parameter, and the variable or parameter is
 declared <TT>final</TT>.
<LI CLASS="li-itemize"><I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> are always-equal if they represent the same
 binary operation, and the corresponding subexpressions are
 always-equal. For example, <TT>i+1</TT> and <TT>i+1</TT> are
 always-equal, if <TT>i</TT> is a <TT>final</TT> local variable.
</UL>
Otherwise, the compiler conservatively assumes that the expressions
are not always-equal.<BR>
<BR>
<!--TOC subsubsection 3.6.2&nbsp;&nbsp;Nesting-->

<H4 CLASS="subsubsection"><A NAME="htoc29">3.6.2</A>&nbsp;&nbsp;Nesting<A NAME="sec:rpls:comparing:nest"></A></H4><!--SEC END -->

<!--NAME rpls.comparing.nest-->
<BR>
<BR>
The meaning of the nesting relation on RPLs is that one RPL is a
descendant of another in the region tree. Nesting is important
because, in conjunction with partially specified RPLs, it defines
inclusion of RPLs (§&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>). Four rules
govern nesting of RPLs.<BR>
<BR>
<B>Nesting under <TT>Root</TT>:</B> Any RPL is nested under
<TT>Root</TT>.<BR>
<BR>
<B>Nesting by syntax:</B> One RPL is nested under another if the
second is a prefix of the first. For example, <TT>A:B</TT> is nested
under <TT>A</TT>, <TT>R:A</TT> is nested under <TT>R</TT>, and <TT>this:[0]</TT>
is nested under <TT>this</TT>.<BR>
<BR>
<B>Nesting by inclusion:</B> If one RPL is included in another, then
the first RPL is nested under the second. For example, <TT>A:B</TT> is
included in <TT>A:*</TT> (see §&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>), so
<TT>A:B</TT> is nested under <TT>A:*</TT>.<BR>
<BR>
<B>Nesting by ownership:</B> An RPL that starts with a variable
element (§&nbsp;<A HREF="#sec:rpls:basic:var">3.1.5</A>) is nested under the owner RPL of
the variable (§&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>). For example, in
the following code, the method parameter <TT>param</TT> has type
<TT>NestByOwnership&lt;R&gt;</TT>, so it is nested under <TT>R</TT> when used as
an RPL:

 <DIV CLASS="dpjlisting"><TT><B>class</B> NestByOwnership&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;method(<B>final</B> NestByOwnership&lt;R&gt; param) {
        <FONT COLOR="fuchsia"><EM>// param is used as an RPL here; it is nested under R</EM></FONT>
        NestByOwnership&lt;param&gt; localVar = <B>new</B> NestByOwnership&lt;param&gt;();
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsubsection 3.6.3&nbsp;&nbsp;Inclusion-->

<H4 CLASS="subsubsection"><A NAME="htoc30">3.6.3</A>&nbsp;&nbsp;Inclusion<A NAME="sec:rpls:comparing:include"></A></H4><!--SEC END -->

<!--NAME rpls.comparing.include-->
<BR>
<BR>
The meaning of the inclusion relation on RPLs is that the set of
regions represented by one RPL is included (in the sense of set
inclusion) in the set of regions represented by another RPL.
Inclusion of RPLs is important in checking type comparisons
(§§&nbsp;<A HREF="#sec:types:class:compare">4.1.2</A>,&nbsp;<A HREF="#sec:types:array:compare">4.2.4</A>)
and subeffects (§&nbsp;<A HREF="#sec:effects:subeffects">5.6</A>). The following rules
govern inclusion of RPLs.<BR>
<BR>
<B>Inclusion by equivalence:</B> One RPL is included in another if
the RPLs are equivalent (§&nbsp;<A HREF="#sec:rpls:comparing:equiv">3.6.1</A>).<BR>
<BR>
<B>Inclusion by trailing <TT>*</TT>:</B> One RPL is included in another
if the second ends with <TT>*</TT>, and the first is nested under the
second after the trailing <TT>*</TT> is removed. For example,
<TT>A:B:C</TT> is included in <TT>A:*</TT>, because <TT>A:B:C</TT> is nested
under <TT>A</TT> (i.e., <TT>A:*</TT> with the <TT>*</TT> removed).<BR>
<BR>
<B>Inclusion by trailing elements other than <TT>*</TT>:</B> One RPL is
included in another if the last element of the first is included in
the last element of the second, and inclusion holds for the RPLs after
stripping the last elements of both. One RPL element is included in
another if the elements are equivalent
(§&nbsp;<A HREF="#sec:rpls:comparing:equiv">3.6.1</A>) or the first element is any array
index element or <TT>[?]</TT>, and the second is <TT>[?]</TT>. For example:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>A:B</TT> is included in <TT>A:*:B</TT>, because <TT>B</TT> is
 included in <TT>B</TT>, and <TT>A</TT> is included in <TT>A:*</TT>
<LI CLASS="li-itemize"><TT>A:[0]</TT> is included in <TT>A:*:[?]</TT>, because <TT>[0]</TT> is
 included in <TT>[?]</TT>, and <TT>A</TT> is included in <TT>A:*</TT>.
<LI CLASS="li-itemize"><TT>A:*:B</TT> is not included in <TT>A:B</TT>, because <TT>A:*</TT> is
 not included in <TT>A</TT>.
<LI CLASS="li-itemize"><TT>A:[?]</TT> is not included in <TT>A:[0]</TT>, because <TT>[?]</TT>
 is not included in <TT>[0]</TT>.
</UL>
<B>Inclusion by constrant:</B> Two RPLs may be constrained to be
included, one in the other. In the current language specification,
the only way this can happen is when capturing a type
(§&nbsp;<A HREF="#sec:types:exp">4.3</A>). There is no way for the programmer to
directly write an inclusion constraint on RPLs.<BR>
<BR>
<!--TOC subsubsection 3.6.4&nbsp;&nbsp;Disjointness-->

<H4 CLASS="subsubsection"><A NAME="htoc31">3.6.4</A>&nbsp;&nbsp;Disjointness<A NAME="sec:rpls:comparing:disjoint"></A></H4><!--SEC END -->

<!--NAME rpls.comparing.disjoint.html-->
<BR>
<BR>
The meaning of the disjointness relation on RPLs is that the sets of
regions represented by the RPLs have no common elements. This
relation is important in checking noninterference
(§&nbsp;<A HREF="#sec:effects:nonint">5.7</A>).<BR>
<BR>
<B>Disjoint RPLs:</B> The following rules govern disjointness of
RPLs.<BR>
<BR>
<I>Distinctions from the left:</I> Two RPLs are disjoint if they
start with a sequence of one or more equivalent elements, and then
their elements are disjoint, where disjoint elements are defined
below. An application of this rule is called a &#8220;distinction from the
left,&#8221; because it uses a difference in the RPLs starting on the left
to infer disjointness. This rule works because RPLs form a tree, so
two RPLs that start the same then diverge must be on different
branches of the tree.<BR>
<BR>
The following are examples of distinctions from the left, assuming
<TT>A</TT> and <TT>B</TT> are class region names
(§&nbsp;<A HREF="#sec:rpls:basic:class">3.1.2</A>):
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>A</TT> and <TT>B</TT> are disjoint, because they are short for
 <TT>Root:A</TT> and <TT>Root:B</TT>, so they start with the same element
 <TT>Root</TT> and then diverge. <TT>A:*</TT> and <TT>B:*</TT> are also
 disjoint, for the same reason.
<LI CLASS="li-itemize">If <TT>R</TT> is a region parameter, then <TT>R:A</TT> and <TT>R:B</TT>
 are disjoint, as are <TT>R:A:*</TT> and <TT>R:B:*</TT>.
<LI CLASS="li-itemize"><TT>this:A</TT> and <TT>this:B</TT> are disjoint, as are
 <TT>this:A:*</TT> and <TT>this:B:*</TT>.
</UL>
Note that there must be at least one equivalent element for a
distinction to from the left. For example, region parameters <TT>R1</TT>
and <TT>R2</TT> are not disjoint unless they are constrained to be
disjoint (see below).<BR>
<BR>
<I>Distinctions from the right:</I> Two RPLs are disjoint if they
end with disjoint elements, where disjoint elements are defined below.
An application of this rule is called a &#8220;distinction from the
right,&#8221; because it uses a difference in the RPLs starting on the
right to infer disjointness. This rule works because two RPLs that
end in disjoint elements can never refer to the same regions, even
after substituting for parameters, <TT>*</TT>, and <TT>[?]</TT>.<BR>
<BR>
The following are examples of distinctions from the right, assuming
<TT>A</TT> and <TT>B</TT> are class region names
(§&nbsp;<A HREF="#sec:rpls:basic:class">3.1.2</A>):
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Root:*:A</TT> and <TT>Root:*:B</TT> are disjoint RPLs.
<LI CLASS="li-itemize"><TT>R:*:A</TT> and <TT>R:*:B</TT> are disjoint RPLs.
<LI CLASS="li-itemize"><TT>this:*:A</TT> and <TT>this:*:B</TT> are disjoint RPLs.
</UL>
<I>Disjointness by constraint:</I> Two RPLs are disjoint if they are
each included in another RPL (<A HREF="#sec:rpls:comparing:include">3.6.3</A>) and
the including RPLs are constrained to be disjoint
(<A HREF="#sec:classes:params:disjoint">2.4.3</A>). For example, in the following
code, <TT>R1:r</TT> and <TT>R2:r</TT> are disjoint RPLs, because <TT>R1:r</TT>
is included in <TT>R1:*</TT>, <TT>R2:r</TT> is included in <TT>R2:*</TT>, and
<TT>R1:*</TT> and <TT>R2:*</TT> are constrained to be disjoint.

 <DIV CLASS="dpjlisting"><TT><B>class</B> DisjointConstraints&lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2 | R1:* # R2:*&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> r;
    <B>void</B> method() {
        DisjointConstraints&lt;R1:r&gt; dc1 =
            <B>new</B> DisjointConstraints&lt;R1:r&gt;();
        DisjointConstraints&lt;R2:r&gt; dc2 =
            <B>new</B> DisjointConstraints&lt;R2:r&gt;();
    }
}</TT></DIV><BR>
<BR>
Note that <TT>R1:r</TT> and <TT>R2:r</TT> would <EM>not</EM> be disjoint if
the constraint were the weaker <TT>R1 # R2</TT>; the <TT>*</TT> is
required. This is because nesting does not imply inclusion. For
example, setting <TT>R1</TT>=<TT>A</TT> and <TT>R2</TT>=<TT>A:B</TT> satisfies
<TT>R1 # R2</TT>. But then <TT>R1:B</TT>=<TT>A:B</TT> is not disjoint from
<TT>R2</TT>, after substituting <TT>A</TT> for <TT>R1</TT> and <TT>A:B</TT> for
<TT>R2</TT>. However, <TT>R1</TT>=<TT>A</TT> and <TT>R2</TT>=<TT>A:B</TT> does
not satisfy <TT>R1:* # R2:*</TT>, because <TT>A:B</TT> is included in
<TT>A:*</TT>.<BR>
<BR>
<B>Disjoint RPL elements:</B> Two RPL elements are disjoint if one
is a name and the other is an array index (including <TT>[?]</TT>); or
they are different names; or they are the array index elements
<TT>[<I>e</I><SUB>1</SUB>]</TT> and <TT>[<I>e</I><SUB>2</SUB>]</TT>, where <I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> always evaluate
to different values at runtime (i.e., are &#8220;never-equal
expressions&#8221;).<BR>
<BR>
Since the compiler can't always know when two expressions evaluate to
the same value, it applies the following conservative rules to
identify pairs of never-equal expressions:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> are never-equal if they refer to different
 compile-time constants. For example, 0 and 1 are never-equal.
<LI CLASS="li-itemize"><I>e</I><SUB>1</SUB> and <I>e</I><SUB>2</SUB> are never-equal if they represent the same
 binary operation, one of the corresponding subexpressions is
 always-equal (§&nbsp;<A HREF="#sec:rpls:comparing:equiv">3.6.1</A>), and the other is
 never-equal. For example, if <TT>i</TT> is a <TT>final</TT> local
 variable, then <TT>i+1</TT> and <TT>i+2</TT> are never-equal.
</UL>
Otherwise, the compiler conservatively assumes that the expressions
are not never-equal.<BR>
<BR>

<!--TOC section 4&nbsp;&nbsp;Types-->

<H2 CLASS="section"><A NAME="htoc32">4</A>&nbsp;&nbsp;Types<A NAME="sec:types"></A></H2><!--SEC END -->

<!--NAME types.html-->
<BR>
<BR>
DPJ extends the Java type system by adding RPLs (§&nbsp;<A HREF="#sec:rpls">3</A>) to
class and array types. The RPLs in the types support the effect
system: different class and array objects can be created with
different RPLs, and the compiler can use the RPLs to infer the effect
of an operation on the object (i.e., accessing a class field or array
cell, or invoking a method).<BR>
<BR>
This section discusses DPJ's extensions to the Java type system:
§&nbsp;<A HREF="#sec:types:class">4.1</A> discusses class and interface types,
§&nbsp;<A HREF="#sec:types:array">4.2</A> discusses array types, and
§&nbsp;<A HREF="#sec:types:exp">4.3</A> discusses the rules for determining the type of
an expression (e.g., what type is returned by calling a method).<BR>
<BR>
<!--TOC subsection 4.1&nbsp;&nbsp;Class and Interface Types
-->

<H3 CLASS="subsection"><A NAME="htoc33">4.1</A>&nbsp;&nbsp;Class and Interface Types
<A NAME="sec:types:class"></A></H3><!--SEC END -->

<!--NAME types.class.html-->
<BR>
<BR>
This section discusses DPJ's class and interface types. We will use
the term &#8220;class&#8221; throughout this section, with the understanding
that the concepts apply identically to interfaces, unless otherwise
noted. §&nbsp;<A HREF="#sec:types:class:instant">4.1.1</A> discusses the instantiation
of a class to a type by supplying RPLs for its parameters.
§&nbsp;<A HREF="#sec:types:class:compare">4.1.2</A> explains how the DPJ compiler
compares two class types for compatibility, for example in checking an
assignment statement. §&nbsp;<A HREF="#sec:types:class:cast">4.1.3</A> discusses casting
one type to another in DPJ. §&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>
explains <EM>owner RPLs</EM>, which determine the nesting relation for
variable RPLs (§&nbsp;<A HREF="#sec:rpls:basic:var">3.1.5</A>).<BR>
<BR>
<!--TOC subsubsection 4.1.1&nbsp;&nbsp;Writing Class Types-->

<H4 CLASS="subsubsection"><A NAME="htoc34">4.1.1</A>&nbsp;&nbsp;Writing Class Types<A NAME="sec:types:class:instant"></A></H4><!--SEC END -->

<!--NAME types.class.instant-->
<BR>
<BR>
In DPJ, as in generic Java, a class with parameters defines a family
of types, one for each set of arguments to the parameters. However,
in addition to type parameters, DPJ classes can have region parameters
(§&nbsp;<A HREF="#sec:classes:params:class">2.4.1</A>). When writing a DPJ class type,
parameter arguments must be supplied. They can be supplied implicitly
or explicitly.<BR>
<BR>
<B>Implicit parameter arguments:</B> As in generic Java, a DPJ class
with parameters may always be used as a type by just naming the class,
without providing any explicit parameter arguments. For example, the
following code is valid:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ImplicitArgs&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="fuchsia"><EM>// ImplicitArgs is a valid type here</EM></FONT>
    ImplicitArgs field = <B>null</B>;
}</TT></DIV><BR>
<BR>
When the type arguments are omitted for a class with parameters, the
following occurs:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The type parameters, if any, have no argument. That is, the
 type functions as a <EM>raw type</EM> in generic Java.
<LI CLASS="li-itemize">The RPL parameters, if any, become bound to <TT>Root</TT>.
</UL>
In the example written above, <TT>field</TT> is of class type
<TT>ImplicitArgs</TT>, with <TT>Root</TT> bound to <TT>R</TT> and no
argument for <TT>T</TT>.<BR>
<BR>
Implicit parameter arguments are useful in two ways. First they help
with porting legacy Java code to DPJ. For example, adding a region
parameter to a preexisting class will not break any code that uses the
class. Second, because region arguments are used to compute the
effects on fields of a class (§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A>), they are
usually not important for code that is never invoked in a parallel
context (for example, in a sequential initialization phase). For this
code, the programmer can avoid writing the arguments.<BR>
<BR>
<B>Explicit parameter arguments:</B> As in Java, if explicit
arguments to class parameters are given, then they appear in angle
brackets after the class name. The arguments must appear in the same
order in which the parameters appear in the class definition; so, in
particular, any type arguments must precede any RPL arguments. Any of
the type arguments may be preceded by the keyword <TT>type</TT>, and any
of the RPL arguments may be preceded by the keyword <TT>region</TT>; but
the keywords are optional, as the compiler can infer which are the
types and which are the RPLs from the class definition.<BR>
<BR>
For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ExplicitArgs&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <FONT COLOR="fuchsia"><EM>// Instantiate an ExplicitArgs type with T=Object, R=Root</EM></FONT>
    ExplicitArgs&lt;Object,Root&gt; field;
}</TT></DIV>This code defines a class <TT>ExplicitArgs</TT> with one type parameter
<TT>T</TT> and one RPL parameter <TT>R</TT>. The field <TT>field</TT> has
class type <TT>ExplicitArgs</TT> with <TT>T</TT>=<TT>Object</TT> and
<TT>R</TT>=<TT>Root</TT>.<BR>
<BR>
The number of type arguments must exactly match the number of type
parameters. However, fewer RPL arguments can be given than the number
of RPL parameters; any missing RPL arguments (matching the arguments
that are there from the left) are implicitly bound to <TT>Root</TT>. For
example, in the code above, we could have written the type of field
<TT>field</TT> as <TT>ExplicitArgs&lt;Object&gt;</TT>. Here is another example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ImplicitRPLArg&lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2&gt; {
    <FONT COLOR="blue"><B>region</B></FONT> r;
    ImplicitRPLArg&lt;r&gt; field;
}</TT></DIV>The class <TT>ImplicitRPLArg</TT> has two parameters <TT>R1</TT> and
<TT>R2</TT>, but the type <TT>ImplicitRPLArg&lt;r&gt;</TT> of <TT>field</TT> has only
one explicit RPL argument, <TT>r</TT>. <TT>r</TT> is bound to the first
parameter <TT>R1</TT>, and the second parameter has no argument, so it is
bound to <TT>Root</TT>. This type is the same as
<TT>ImplicitRPLArg&lt;r,Root&gt;</TT>.<BR>
<BR>
<!--TOC subsubsection 4.1.2&nbsp;&nbsp;Class Type Comparisons-->

<H4 CLASS="subsubsection"><A NAME="htoc35">4.1.2</A>&nbsp;&nbsp;Class Type Comparisons<A NAME="sec:types:class:compare"></A></H4><!--SEC END -->

<!--NAME types.class.compare.html-->
<BR>
<BR>
The notion of <EM>type comparison</EM> is important in Java. For
example, if class <TT>B</TT> extends class <TT>A</TT>, and variable <TT>x</TT>
has type <TT>A</TT>, then you can assign an object of type <TT>B</TT> to
<TT>x</TT>; but it is not permissible to assign an object of some type
<TT>C</TT> that does not extend <TT>A</TT> (or extend another class that
extends <TT>A</TT>, etc.).<BR>
<BR>
DPJ extends Java's type comparison rules to account for the RPL
information in the class types. The rules ensure that the actual type
of an object always corresponds to the type that appears in a program
variable storing a reference to the object. This property in turn
allows the compiler to reason soundly about effects by looking at the
types of variables. If the &#8220;wrong&#8221; type of object could be assigned
to a variable, then this kind of reasoning would not work.<BR>
<BR>
To state the comparison rules for DPJ, we introduce the concept of the
<EM>DPJ erasure</EM> of a type. This is the type obtained by ignoring
all RPL parameters and arguments. For example, suppose class <TT>C</TT>
has a type parameter <TT>T</TT> and a region parameter <TT>R</TT>. Then the
DPJ erasure of <TT>C&lt;Object,Root&gt;</TT> is <TT>C&lt;Object&gt;</TT>.<BR>
<BR>
The following rules determine whether a variable of class type <I>T</I><SUB>1</SUB>
can be assigned to a variable of class type <I>T</I><SUB>2</SUB> in DPJ.<BR>
<BR>
<B>Types that instantiate the same class:</B> <I>T</I><SUB>1</SUB> may be assigned
to <I>T</I><SUB>2</SUB> if the two types instantiate the same class, the DPJ erasure
of <I>T</I><SUB>1</SUB> may be assigned to the DPJ erasure of <I>T</I><SUB>2</SUB> in ordinary Java,
and the RPL arguments of <I>T</I><SUB>1</SUB> are included
(§&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>) in the corresponding arguments
of <I>T</I><SUB>2</SUB>.<BR>
<BR>
Here are some examples of compatible types that instantiate the same
class:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>C&lt;Root&gt;</TT> may be assigned to <TT>C&lt;Root:*&gt;</TT>, because the
 DPJ erasures are identical, and <TT>Root:*</TT> includes <TT>Root</TT>.
<LI CLASS="li-itemize"><TT>C&lt;Object,Root&gt;</TT> may be assigned to <TT>C&lt;Object,Root:*&gt;</TT>
 for the same reason.
<LI CLASS="li-itemize"><TT>C&lt;C&lt;Object,Root&gt;,Root&gt;</TT> may be assigned to <TT>C&lt;? extends
 C&lt;Object,Root:*&gt;,Root:*&gt;</TT>. The reasoning here is a bit more
 complicated. First, look at the DPJ erasures of the types, that is
 <TT>C&lt;C&lt;Object,Root&gt;&gt;</TT> and <TT>C&lt;? extends C&lt;Object,Root:*&gt;&gt;</TT>.
 According to the rules for Java generic wildcards, the first type
 may be assigned to the second if <TT>C&lt;Object,Root&gt;</TT> may be
 assigned to <TT>C&lt;Object,Root:*&gt;</TT>. To figure that out, we have to
 apply the rule recursively. First look at the DPJ erasures:
 assigning <TT>C&lt;Object&gt;</TT> to <TT>C&lt;Object&gt;</TT> is OK. Now look at the
 RPLs: <TT>Root:*</TT> includes <TT>Root</TT>. So that test checks out.
 Now look at the RPL arguments in the original types: <TT>Root:*</TT>
 includes <TT>Root</TT>. So that test checks out as well.
</UL>

Here are some examples of incompatible types that instantiate the same
class, assuming <TT>r1</TT> and <TT>r2</TT> are region names:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>C&lt;r1&gt;</TT> may not be assigned to <TT>C&lt;r2&gt;</TT>, because <TT>r1</TT>
is not included in <TT>r2</TT>.
<LI CLASS="li-itemize"><TT>C&lt;Object,r1&gt;</TT> may not be assigned to <TT>C&lt;Object,r2&gt;</TT> for
 the same reason.
<LI CLASS="li-itemize"><TT>C&lt;C&lt;Object,r1&gt;,Root&gt;</TT> may not be assigned to <TT>C&lt;?
 extends C&lt;Object,r2&gt;,Root</TT> because <TT>C&lt;Object,r1&gt;</TT> may not be
 assigned to <TT>C&lt;Object,r2&gt;</TT>.
</UL>
<B>Types that instantiate different classes:</B> <I>T</I><SUB>1</SUB> may be
assigned to <I>T</I><SUB>2</SUB> if <I>T</I><SUB>2</SUB> is a <EM>direct supertype</EM> or
<EM>indirect supertype</EM> of <I>T</I><SUB>1</SUB>.<BR>
<BR>
<I>Direct supertypes: T</I><SUB>2</SUB> is a direct supertype of <I>T</I><SUB>1</SUB> if a
type with <I>T</I><SUB>2</SUB>'s class or interface appears in an <TT>extends</TT> or
<TT>implements</TT> clause of <I>T</I><SUB>1</SUB>'s class or interface, and that type
is assignable to <I>T</I><SUB>2</SUB> after substituting arguments for parameters
according to <I>T</I><SUB>1</SUB>.<BR>
<BR>
For example:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Assume class declarations <TT>class B&lt;region R&gt; extends A&lt;R&gt;</TT>
 and <TT>class A&lt;region R&gt;</TT>. Then <TT>A&lt;Root&gt;</TT> is a direct
 supertype of <TT>B&lt;Root&gt;</TT>, because <TT>A&lt;R&gt;</TT> appears in the
 <TT>extends</TT> clause of <TT>B</TT>, and the type obtained by
 substituting <TT>Root</TT> for <TT>R</TT> from the type <TT>B&lt;Root&gt;</TT> is
 <TT>A&lt;Root&gt;</TT>.
<LI CLASS="li-itemize">With the same assumptions as in (1), <TT>A&lt;Root:*&gt;</TT> is a direct
 supertype of <TT>B&lt;Root&gt;</TT>, because <TT>A&lt;Root&gt;</TT> is assignable to
 <TT>A&lt;Root:*&gt;</TT>.
<LI CLASS="li-itemize">Assume class declaration <TT>class B&lt;type T, region R&gt; extends
 A&lt;B&lt;Root&gt;,R&gt;</TT>. Then <TT>A&lt;B&lt;Root&gt;,Root:*&gt;</TT> is a direct supertype
 of <TT>B&lt;Object,Root&gt;</TT>.
</UL>

<I>Indirect supertypes: T</I><SUB>2</SUB> is an indirect supertype of <I>T</I><SUB>1</SUB>
if there is a chain of direct supertypes connecting <I>T</I><SUB>1</SUB> to <I>T</I><SUB>2</SUB>.
For example, if we have class declarations <TT>class C&lt;region R&gt;
 extends B&lt;R&gt;</TT>, <TT>class B&lt;region R&gt; extends A&lt;R&gt;</TT> and <TT>class
 A&lt;region R&gt;</TT>, then <TT>A&lt;Root&gt;</TT> is an indirect supertype of
<TT>C&lt;Root&gt;</TT>, because <TT>A&lt;Root&gt;</TT> is a direct supertype of
<TT>B&lt;Root&gt;</TT>, and <TT>B&lt;Root&gt;</TT> is a direct supertype of
<TT>C&lt;Root&gt;</TT>.<BR>
<BR>
<!--TOC subsubsection 4.1.3&nbsp;&nbsp;Class Type Casts-->

<H4 CLASS="subsubsection"><A NAME="htoc36">4.1.3</A>&nbsp;&nbsp;Class Type Casts<A NAME="sec:types:class:cast"></A></H4><!--SEC END -->

<!--NAME types.class.cast.html-->
<BR>
<BR>
One DPJ type may be cast to another if the cast would be allowed for
the DPJ erasures of the types (§&nbsp;<A HREF="#sec:types:class:compare">4.1.2</A>) in
ordinary Java. For example, assuming a class declared as <TT>class
 C&lt;region R&gt;</TT> the following cast is legal:

 <DIV CLASS="dpjlisting"><TT>C&lt;r1&gt; x = (C&lt;r1&gt;) <B>new</B> C&lt;r2&gt;();</TT></DIV>This code creates an object of type <TT>C&lt;r2&gt;</TT> on the right-hand
side, then casts it to type <TT>C&lt;r1&gt;</TT> before assigning it to a
variable <TT>x</TT> of type <TT>C&lt;r1&gt;</TT>. The DPJ erasure of both the
<TT>new</TT> expression and the target type is <TT>C</TT>, so the cast is
allowed. Without the cast, <TT>C&lt;r2&gt;</TT> is not assignable to
<TT>C&lt;r1&gt;</TT>, because <TT>r2</TT> does not include <TT>r1</TT>.<BR>
<BR>
However, the following cast is not legal, assuming a class declared as
<TT>class C&lt;type T, region R&gt;</TT>:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Compile error!</EM></FONT>
C&lt;C&lt;Object,r1&gt;,r1 x =
  (C&lt;C&lt;Object,r1&gt;,r1&gt;) <B>new</B> C&lt;C&lt;Object,r2&gt;,r2&gt;();</TT></DIV>That is because the DPJ erasure of the type of the <TT>new</TT>
expression is <TT>C&lt;Object,r2&gt;</TT>; the DPJ erasure of the target type
is <TT>C&lt;Object,r1&gt;</TT>; and these two types are not compatible.<BR>
<BR>
As in ordinary Java, casts allow assignments that the compiler cannot
check for correctness. That is, in general for a statement of the
form

 <DIV CLASS="dpjlisting"><TT>T x = (T) y</TT></DIV>there is no way to ensure at compile time that the type of the object
<TT>y</TT> is really consistent with the type <TT>T</TT> of variable
<TT>x</TT>. Further, for efficiency reasons, DPJ has no checks for
catching bad assignments at runtime. Therefore, a DPJ program with
casts in it is a potentially nondeterministic program! Casts should
be used very carefully and only as a last resort, when there is no
other way to express the program.<BR>
<BR>
<!--TOC subsubsection 4.1.4&nbsp;&nbsp;Owner RPLs-->

<H4 CLASS="subsubsection"><A NAME="htoc37">4.1.4</A>&nbsp;&nbsp;Owner RPLs<A NAME="sec:types:class:owner-rpl"></A></H4><!--SEC END -->

<!--NAME types.class.owner-rpl.html-->
<BR>
<BR>
Owner RPLs define the nesting relationship between <TT>final</TT> local
variables used as RPLs (§&nbsp;<A HREF="#sec:rpls:basic:var">3.1.5</A>) and other RPLs.
A variable RPL is nested under the owner RPL of its class type
(§&nbsp;<A HREF="#sec:rpls:comparing:nest">3.6.2</A>).<BR>
<BR>
If a class has RPL parameters, then the owner RPL of a type
instantiating the class is the argument to the first parameter. For
example, assuming a class declaration <TT>class C&lt;region R1,R2&gt;</TT>, and
region names <TT>r1</TT> and <TT>r2</TT>, the owner RPL of the type
<TT>C&lt;r1,r2&gt;</TT> is <TT>r1</TT>.<BR>
<BR>
If a class does not have RPL parameters, then the owner RPL of a type
instantiating the class is <TT>Root</TT>. For example, assuming a class
declaration <TT>class C&lt;type T&gt;</TT>, the owner RPL of the type
<TT>C&lt;Object&gt;</TT> is <TT>Root</TT>.
<BR>
<BR>
<!--TOC subsection 4.2&nbsp;&nbsp;Array Types-->

<H3 CLASS="subsection"><A NAME="htoc38">4.2</A>&nbsp;&nbsp;Array Types<A NAME="sec:types:array"></A></H3><!--SEC END -->

<!--NAME types.array.html-->
<BR>
<BR>
This section discusses DPJ's array types.
§&nbsp;<A HREF="#sec:types:array:instant">4.2.1</A> discusses the instantiation of an
array to a type by supplying an RPL for its parameter. This assigns
an RPL to each cell of the array. §&nbsp;<A HREF="#sec:types:array:ipa">4.2.2</A>
discusses DPJ's <EM>index-parameterized array type</EM>, which provides
a way to assign a different region to each cell of an array. This is
useful for updating different array cells (or different objects stored
in different array cells) in parallel. §&nbsp;<A HREF="#sec:types:array:new">4.2.3</A>
explains the creation of new array objects.
§&nbsp;<A HREF="#sec:types:array:compare">4.2.4</A> explains how the DPJ compiler
compares two array types for compatibility, for example in checking an
assignment statement. §&nbsp;<A HREF="#sec:types:array:cast">4.2.5</A> discusses casting
one array type to another in DPJ.<BR>
<BR>
Because Java arrays do not support slices (e.g., extracting a
contiguous subsection of an array), DPJ provides a generic class
called <TT>DPJArray</TT> with an interface similar to Java's
<TT>ArrayList</TT> that supports slices. There are also versions of
<TT>DPJArray</TT> specialized to the various primitive types.
§&nbsp;<A HREF="#sec:runtime:array">7.1</A> discusses these classes.<BR>
<BR>
<!--TOC subsubsection 4.2.1&nbsp;&nbsp;Writing Array Types-->

<H4 CLASS="subsubsection"><A NAME="htoc39">4.2.1</A>&nbsp;&nbsp;Writing Array Types<A NAME="sec:types:array:instant"></A></H4><!--SEC END -->

<!--NAME types.array.instant.html-->
<BR>
<BR>
Every DPJ array type has exactly one RPL parameter. It works
similarly to a class RPL parameter. When you write an array type, you
must either specify an explicit RPL as an argument to the parameter,
or use the default RPL. The explicit argument is given in angle
brackets, after the square brackets. If you leave out the explicit
argument, the default is <TT>Root</TT>. In either case, the RPL argument
specifies the RPL associated with the cells of the array.<BR>
<BR>
For example:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Array of int with cells in Root</EM></FONT>
<B>int</B>[]&lt;Root&gt;
<FONT COLOR="fuchsia"><EM>// Same as int[]&lt;Root&gt;</EM></FONT>
<B>int</B>[]
<FONT COLOR="fuchsia"><EM>// Array of int with cells in R</EM></FONT>
<B>int</B>[]&lt;R&gt;</TT></DIV><BR>
<BR>
As in ordinary Java, you can construct arrays whose elements are
themselves arrays. In this case the RPL argument to the array type is
the argument (either implicit or explicit) associated with the
<EM>leftmost</EM> pair of brackets. The type of an element is given by
deleting the leftmost set of brackets and its RPL argument, if any.
For example:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Array with cells in R1; each element is an int[]&lt;R2&gt;</EM></FONT>
<B>int</B>[]&lt;R1&gt;[]&lt;R2&gt;
<FONT COLOR="fuchsia"><EM>// Array with cells in Root; each element is an int[]&lt;R&gt;
// Same as int[]&lt;Root&gt;[]&lt;R&gt;</EM></FONT>
<B>int</B>[][]&lt;R&gt;
<FONT COLOR="fuchsia"><EM>// Array with cells in R; each element is an int[]&lt;Root&gt;
// Same as int[]&lt;R&gt;[]&lt;Root&gt;</EM></FONT>
<B>int</B>[]&lt;R&gt;[]</TT></DIV>This process may be continued to arbitrary depth. For example,
<TT>int[]&lt;R1&gt;[]&lt;R2&gt;[]&lt;R3&gt;</TT> is an array with cells in <TT>R1</TT> whose
element type is <TT>int[]&lt;R2&gt;[]&lt;R3&gt;</TT>. The element type in turn is an
array with cells in <TT>R2</TT> whose element type is <TT>int[]&lt;R3&gt;</TT>.<BR>
<BR>
Class and method RPL parameters are frequently given as RPL arguments
to array types. For example, the following class declares a field
<TT>arr</TT> whose type is an array. Both the field <TT>arr</TT> and the
cells of the array are in the RPL given by the class region parameter
<TT>R</TT>:

 <DIV CLASS="dpjlisting"><TT><B>class</B> ArrayClassParam&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B>[]&lt;R&gt; arr <FONT COLOR="blue"><B>in</B></FONT> R;
}</TT></DIV>Notice that without the capability to bind <TT>R</TT> as the RPL argument
to the array type, there would be no way to get the cells of <TT>arr</TT>
in region <TT>R</TT>. The specifier <TT>in R</TT> is insufficient, because
it only specifies the region of the <TT>arr</TT> reference itself, not
the region of the cells of the array that the reference points to.<BR>
<BR>
Method region parameters can also be used to write a method that takes
an array with any region:

 <DIV CLASS="dpjlisting"><TT><B>abstract class</B> ArrayMethodParam {
    <FONT COLOR="fuchsia"><EM>// This method will accept an int[] with any RPL argument</EM></FONT>
    &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> method(<B>int</B>[]&lt;R&gt; arr);
}</TT></DIV><BR>
<BR>
Non-parametric RPLs are generally bound to array parameters when the
arrays are global data. For example, one might declare an array of
data that is initialized once, in a sequential phase, and then never
changes during the computation. One could do that by declaring a
region <TT>ReadOnlyData</TT> and then putting the array in that region:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>region</B></FONT> ReadOnlyData;
<B>final int</B>[]&lt;ReadOnlyData&gt; data = <B>new int</B>[N]&lt;ReadOnlyData&gt;;</TT></DIV>On the right-hand side of the assignment, we have created a new array
of type <TT>int[]&lt;ReadOnlyData&gt;</TT> with <TT>N</TT> elements (see
§&nbsp;<A HREF="#sec:types:array:new">4.2.3</A>).<BR>
<BR>
Inside the parallel computation, with the proper use of disjointness
constraints on parameters and disjoint RPLs, read effects on
<TT>ReadOnlyData</TT> are noninterfering, and write effects on other
regions are noninterfering because the regions are disjoint. See
<EM>The Deterministic Parallel Java Tutorial</EM> for more details.<BR>
<BR>
<!--TOC subsubsection 4.2.2&nbsp;&nbsp;Index-Parameterized Array Types-->

<H4 CLASS="subsubsection"><A NAME="htoc40">4.2.2</A>&nbsp;&nbsp;Index-Parameterized Array Types<A NAME="sec:types:array:ipa"></A></H4><!--SEC END -->

<!--NAME types.array.ipa.html-->
<BR>
<BR>
For parallel computations on arrays, it is often necessary to update
different parts of an array in parallel in different tasks. A DPJ
feature called an <EM>index-parameterized array</EM> allows this to be
done safely. We discuss index-parameterized arrays first for the
simpler case of arrays of primitive and class types, and then for the
case of arrays of arrays.<BR>
<BR>
<B>Arrays of primitive and class types:</B> There are two cases to
consider:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Updating different array cells in different tasks. For example,
 there could be an array of 10,000 cells, with each of 100 tasks
 updating 100 cells. Because the array cells are distinct, there is
 no inteference.
<LI CLASS="li-enumerate">Updating disjoint objects pointed to through different cells in
 different tasks. For example, there could be an array of 10,000
 cells, each of which stores a reference to a unique object. Each of
 100 tasks in parallel could read 100 of the cells, follow the
 references, and update the objects. Because the objects are
 distinct, there is no interference.
</OL>
DPJ's index-parameterized arrays can express both cases.<BR>
<BR>
<I>Updating different array cells:</I> To update different array
cells, it is necessary to put each cell in a different region. DPJ
does this with an <EM>index-parameterized array type</EM>. An
index-parameterized array type uses the array index element <TT>[i]</TT>
(§&nbsp;<A HREF="#sec:rpls:basic:array">3.1.3</A>) in the RPL associated with cell
<TT>i</TT>. Because the index value of <TT>i</TT> is different for every
array cell, every cell has its own region.<BR>
<BR>
To write an index-parameterized array type, you can use the special
array index element <TT>[_]</TT> in the RPL argument of the array type.
This special element is allowed only inside an array type, where it
stands in for the array index element <TT>[i]</TT> associated with each
cell. For example:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Array of int such that cell i is in region [i]</EM></FONT>
<B>int</B>[]&lt;[_]&gt;
<FONT COLOR="fuchsia"><EM>// Array of int such that cell i is in region R:[i]</EM></FONT>
<B>int</B>[]&lt;R:[_]&gt;</TT></DIV>Notice that in the second example, the RPL <TT>R:[i]</TT> gives us two
ways to distinguish array components: we can distinguish whole arrays
from each other by using different bindings to <TT>R</TT>; and we can
distinguish different parts of arrays from each other by using the
different values of <TT>i</TT>.<BR>
<BR>
<I>Updating different objects through different array cells:</I>
Index-parameterized arrays can also handle the case of updates through
references to different objects, by using <TT>[_]</TT> in the RPL
argument of the element type of the array. Every object stored in a
distinct array cell gets its own region, parameterized by the index of
the cell. For example, suppose we have the following simple class
definition:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Data&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> field <FONT COLOR="blue"><B>in</B></FONT> R;
}</TT></DIV>Then we can create the following index-parameterized array:

 <DIV CLASS="dpjlisting"><TT>Data&lt;[_]&gt;[]&lt;[_]&gt; arr = <B>new</B> Data&lt;[_]&gt;[N]&lt;[_]&gt;;</TT></DIV>The type of <TT>arr</TT> is an array such that (1) cell <TT>i</TT> of the
array is in region <TT>[i]</TT>; and (2) cell <TT>i</TT> of the array has
type <TT>Data&lt;[i]&gt;</TT>. Now we can do disjoint initialization of the
array, as before:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, N)
    arr[i] = <B>new</B> Data&lt;[i]&gt;();</TT></DIV>Notice that the type <TT>Data&lt;[i]&gt;</TT> on the left-hand side of the
assignment matches the type of <TT>arr[i]</TT>, as it must; see
§&nbsp;<A HREF="#sec:types:array:compare">4.2.4</A>.<BR>
<BR>
We can also update the objects disjointly through the references in
the array:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, N)
    <FONT COLOR="fuchsia"><EM>// Effect is 'writes [i]'</EM></FONT>
    ++arr[i].field;</TT></DIV>This is a very useful pattern in shared-memory parallel programming.
See <EM>The Deterministic Parallel Java Tutorial</EM> for more realistic examples.<BR>
<BR>
<B>Arrays of arrays:</B> An array of arrays is an array of objects
(the arrays are objects), so it works similarly to an array of class
objects, discussed above. The difference is that with an array of
arrays, there are multiple index dimensions, so it may not be
sufficient to use the single name <TT>[_]</TT> for the index region of
an array. Instead, DPJ allows you to use an explicitly named variable
for each index dimension.<BR>
<BR>
To do this, you write <TT>#</TT><EM>var</EM> after the RPL argument of an
array type, where <EM>var</EM> is an identifier declaring a fresh
variable in scope over the type. That variable can then be used in an
array index element to indicate the index associated with each array
cell. For example, rewriting the types above using the explicit index
variable name <TT>i</TT>:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Same as int[]&lt;[_]&gt;</EM></FONT>
<B>int</B>[]&lt;[i]&gt;#i
<FONT COLOR="fuchsia"><EM>// Same as int[]&lt;R:[_]&gt;</EM></FONT>
<B>int</B>[]&lt;R:[i]&gt;#i</TT></DIV>The variable name doesn't matter; we could have written <TT>j</TT> or
<TT>k</TT> or anything else. The only point of the name is to associate
the variable declaration with an array dimension, so the compiler
knows what dimension is referred to from the name. Notice that if we
use <TT>#_</TT> for the variable declaration, then the index is
<TT>[_]</TT>, as in the default case. In fact this is just how the
compiler implements the default: it declares <TT>#_</TT> for you as the
array index variable if you don't specify one yourself.<BR>
<BR>
In the array-of-array case, each <TT>#</TT><EM>var</EM> declaration is in
scope for the array where it is declared, and all arrays to the right
of that one. For example, the type

 <DIV CLASS="dpjlisting"><TT><B>int</B>[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j}</TT></DIV>defines an array of arrays. The outermost array has cell <TT>i</TT> in
region <TT>i</TT>, and the type of cell <TT>i</TT> is an array of <TT>int</TT>
with cell <TT>j</TT> in region <TT>[i]:[j]</TT>. If we reversed the <TT>i</TT>
and <TT>j</TT> declarations and wrote <TT>int[]&lt;[i]&gt;#j[]&lt;[i]:[j]&gt;#i</TT>,
then we would get a compile error, because <TT>i</TT> is used but not in
scope in the leftmost RPL argument.<BR>
<BR>
This kind of decomposition is useful for dividing a rectangular grid
into rows and columns for disjoint parallel updates. For example, an
initialization of the array might look like this:

 <DIV CLASS="dpjlisting"><TT><B>int</B>[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j A = <B>new int</B>[N]&lt;[i]&gt;#i[M]&lt;[i]:[j]&gt;#j;
<FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, N) {
    <FONT COLOR="fuchsia"><EM>// Effect on [i]:[?] is disjoint on different i iterations</EM></FONT>
    <FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> j <FONT COLOR="blue"><B>in</B></FONT> 0, M) {
        <FONT COLOR="fuchsia"><EM>// Effect on [i]:[j] is disjoint on different j iterations</EM></FONT>
        A[i][j] = INITIAL_VALUE;
    }
}</TT></DIV>For the details of how the compiler would check this example, see
§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A> (computing effects of statements) and
§&nbsp;<A HREF="#sec:effects:nonint">5.7</A> (noninterfering effects).<BR>
<BR>
<!--TOC subsubsection 4.2.3&nbsp;&nbsp;New Arrays-->

<H4 CLASS="subsubsection"><A NAME="htoc41">4.2.3</A>&nbsp;&nbsp;New Arrays<A NAME="sec:types:array:new"></A></H4><!--SEC END -->

<!--NAME types.array.new-->
<BR>
<BR>
Creation of new arrays in DPJ works just as in Java, with the extra
annotations in the array types
(§§&nbsp;<A HREF="#sec:types:array:instant">4.2.1</A>,&nbsp;<A HREF="#sec:types:array:ipa">4.2.2</A>). <BR>
<BR>
<B>Arrays of primitive and class types:</B> To create an array of
<I>n</I> primitive types or class objects, write a DPJ array type with <I>n</I>
in the brackets, instead of empty brackets. For example:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Create an array of 10 int with cells in Root</EM></FONT>
<B>int</B>[]&lt;Root&gt; A1 = <B>new int</B>[10]&lt;Root&gt;;
<FONT COLOR="fuchsia"><EM>// Same as new int[10]&lt;Root&gt;</EM></FONT>
<B>int</B>[] A2 = <B>new int</B>[10];
<FONT COLOR="fuchsia"><EM>// Create an array of 10 int with cells in R</EM></FONT>
<B>int</B>[]&lt;R&gt; A3 = <B>new int</B>[]&lt;R&gt;;
<FONT COLOR="fuchsia"><EM>// Create an array of 10 int such that cell i is in region [i]</EM></FONT>
<B>int</B>[]&lt;[_]&gt; A4 = <B>new int</B>[10]&lt;[_]&gt;;
<FONT COLOR="fuchsia"><EM>// Create an array of 10 int such that cell i is in region R:[i]</EM></FONT>
<B>int</B>[]&lt;R:[_]&gt; A5 = <B>new int</B>[10]&lt;[_]&gt;;
<FONT COLOR="fuchsia"><EM>// Create an array of 10 Data objects such that (1) cell i
// is in region [i]; and (2) cell i has type Data&lt;[i]&gt;</EM></FONT>
Data&lt;[_]&gt;[]&lt;[_]&gt; A6 = <B>new</B> Data&lt;[_]&gt;[10]&lt;[_]&gt;;</TT></DIV><BR>
<BR>
Unfortunately, Java does not let you create arrays of class types that
have generic parameters without an explicit cast. For example, the
following code is illegal:

 <DIV CLASS="dpjlisting"><TT><B>class</B> Data&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    T field <FONT COLOR="blue"><B>in</B></FONT> R;
}
Data&lt;Integer,[_]&gt;[]&lt;[_]&gt; A;
<FONT COLOR="fuchsia"><EM>// The following line causes a 'generic array creation' compile error</EM></FONT>
A = <B>new</B> Data&lt;Integer,[_]&gt;[10]&lt;[_]&gt;;</TT></DIV>To get around this limitation, you need to use a cast:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Rewrite of the last line above so it compiles</EM></FONT>
A = (Data&lt;Integer,[_]&gt;[]&lt;[_]&gt;) <B>new</B> Data[10];</TT></DIV>This code is ugly, but it works. Also, the ugliness is localized to
the point of array creation. Once the array is created and assigned,
everything else works as it should.<BR>
<BR>
An alternative to this ugly code would be to use a <TT>DPJArray</TT>
(§&nbsp;<A HREF="#sec:runtime:array">7.1</A>) instead of a Java array. As of the
current version of DPJ, the <TT>DPJArray</TT> class cannot be used with
index-parameterized regions. It is anticipated that future versions
of DPJ will support index-parameterized <TT>DPJArray</TT>s.<BR>
<BR>
<B>Arrays of arrays:</B> To create an array of arrays, as in
ordinary Java, at least one of the brackets must have a length
expression, and any empty brackets must appear to the right:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="fuchsia"><EM>// Array of 10 cells in R1; each element has type int[]&lt;R2&gt; and
// is initialized to null</EM></FONT>
<B>int</B>[]&lt;R1&gt;[]&lt;R2&gt; A1 = <B>new int</B>[10]&lt;R1&gt;[]&lt;R2&gt;;
<FONT COLOR="fuchsia"><EM>// Same as before, but each element of the array is initialized
// to an array of int[]&lt;R2&gt; with 10 elements</EM></FONT>
<B>int</B>[]&lt;R1&gt;[]&lt;R2&gt; A2 = <B>new int</B>[10]&lt;R1&gt;[10]&lt;R2&gt;;
<FONT COLOR="fuchsia"><EM>// ILLEGAL:  Empty brackets must appear to the right</EM></FONT>
<B>int</B>[]&lt;R1&gt;[]&lt;R2&gt; A2 = <B>new int</B>[]&lt;R1&gt;[10]&lt;R2&gt;;
<FONT COLOR="fuchsia"><EM>// Array of 10 cells such that cell i is in region i; cell i has
// type int[]&lt;[i]:[j]&gt;#j and is initialized to null</EM></FONT>
<B>int</B>[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j = <B>new int</B>[10]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j;
<FONT COLOR="fuchsia"><EM>// Same as before, but each cell is initialized to an array
// with 10 elements</EM></FONT>
<B>int</B>[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j = <B>new int</B>[10]&lt;[i]&gt;#i[10]&lt;[i]:[j]&gt;#j;</TT></DIV><BR>
<BR>
<!--TOC subsubsection 4.2.4&nbsp;&nbsp;Array Type Comparisons-->

<H4 CLASS="subsubsection"><A NAME="htoc42">4.2.4</A>&nbsp;&nbsp;Array Type Comparisons<A NAME="sec:types:array:compare"></A></H4><!--SEC END -->

<!--NAME types.array.compare-->
<BR>
<BR>
The following rules determine when <I>T</I><SUB>1</SUB> may be assigned to <I>T</I><SUB>2</SUB>,
where <I>T</I><SUB>1</SUB> and <I>T</I><SUB>2</SUB> are both array types.<BR>
<BR>
<B>Comparing arrays of primitive types:</B> <I>T</I><SUB>1</SUB> may be assigned to
<I>T</I><SUB>2</SUB> if the element types of <I>T</I><SUB>1</SUB> and <I>T</I><SUB>2</SUB> are both the same
primitive type, and the RPL argument of <I>T</I><SUB>1</SUB> is included in the RPL
argument of <I>T</I><SUB>2</SUB> (§&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>). For example:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>int[]&lt;Root&gt;</TT> may be a assigned to <TT>int[]&lt;Root&gt;</TT>.
<LI CLASS="li-enumerate"><TT>int[]</TT> may be assigned to <TT>int[]</TT>; this is the same as
 case 1.
<LI CLASS="li-enumerate"><TT>int[]&lt;R&gt;</TT> may be assigned to <TT>int[]&lt;R:*&gt;</TT>, because
 <TT>R</TT> is included in <TT>R:*</TT>.
<LI CLASS="li-enumerate"><TT>int[]&lt;r1&gt;</TT> may not be assigned to <TT>int[]&lt;r2&gt;</TT>, because
 <TT>r1</TT> and <TT>r2</TT> are incompatible region names.
</OL>
<B>Comparing arrays of class and array types:</B> <I>T</I><SUB>1</SUB> may be
assigned to <I>T</I><SUB>2</SUB> if the element types of <I>T</I><SUB>1</SUB> and <I>T</I><SUB>2</SUB> are
<EM>array-compatible</EM> class or array types, and the RPL argument of
<I>T</I><SUB>1</SUB> is included in the RPL argument of <I>T</I><SUB>2</SUB>. Two class types are
array-compatible if the element type of <I>T</I><SUB>1</SUB> can be assigned to the
element type of <I>T</I><SUB>2</SUB> using the rules in
§§&nbsp;<A HREF="#sec:types:class:compare">4.1.2</A>,&nbsp;<A HREF="#sec:types:array:compare">4.2.4</A>, but
requiring equivalence (§&nbsp;<A HREF="#sec:rpls:comparing:equiv">3.6.1</A>) instead of
inclusion of RPLs. For example:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>C&lt;R&gt;[]&lt;R&gt;</TT> may be a assigned to <TT>C&lt;R&gt;[]&lt;R:*&gt;</TT>, because
 <TT>C&lt;R&gt;</TT> is array compatible with itself, and <TT>R</TT> is included
 in <TT>R:*</TT>.
<LI CLASS="li-enumerate"><TT>int[]&lt;R&gt;[]&lt;R&gt;</TT> may be assigned to <TT>int[]&lt;R&gt;[]&lt;R:*&gt;</TT>,
 because <TT>int[]&lt;R&gt;</TT> is array compatible with itself, and <TT>R</TT>
 is included in <TT>R</TT>.
<LI CLASS="li-enumerate"><TT>C&lt;R&gt;[]&lt;R&gt;</TT> may not be assigned to <TT>C&lt;R:*&gt;[]&lt;R:*&gt;</TT>,
 because <TT>C&lt;R&gt;</TT> and <TT>C&lt;R:*&gt;</TT> are not array-compatible.
<LI CLASS="li-enumerate"><TT>int[]&lt;R&gt;[]&lt;R&gt;</TT> may not be assigned to
 <TT>int[]&lt;R:*&gt;[]&lt;R:*&gt;</TT>, because <TT>int[]&lt;R&gt;</TT> and <TT>int[]&lt;R:*&gt;</TT>
 are not array compatible.
</OL>
The extra requirement of array-compatibility is introduced to avoid
problems like this:

 <DIV CLASS="dpjlisting"><TT><B>class</B> C&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; { ... }
<FONT COLOR="blue"><B>region</B></FONT> r1, r2;
<FONT COLOR="fuchsia"><EM>// Create an array of 10 C&lt;r1&gt;</EM></FONT>
C&lt;r1&gt;[] arr = <B>new</B> C&lt;r1&gt;[10];
<FONT COLOR="fuchsia"><EM>// Not really allowed, but would be without array compatibility</EM></FONT>
C&lt;*&gt;[] = badArr;
<FONT COLOR="fuchsia"><EM>// Inconsistent types!  Assigning C&lt;r2&gt; to a cell of arr</EM></FONT>
badArr[0] = <B>new</B> C&lt;r2&gt;();</TT></DIV><BR>
<BR>
<!--TOC subsubsection 4.2.5&nbsp;&nbsp;Array Type Casts-->

<H4 CLASS="subsubsection"><A NAME="htoc43">4.2.5</A>&nbsp;&nbsp;Array Type Casts<A NAME="sec:types:array:cast"></A></H4><!--SEC END -->

<!--NAME types.array.cast.html-->
<BR>
<BR>
Casts of array types have the same rules as casts of class types
(§&nbsp;<A HREF="#sec:types:class:cast">4.1.3</A>). The cast is allowed if it would be
allowed for the DPJ erasures of the types in ordinary Java. The DPJ
erasure of an array type is computed by erasing all the DPJ region
information from the entire type. For example:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The DPJ erasure of <TT>int[]&lt;R&gt;</TT> is <TT>int[]</TT>.
<LI CLASS="li-itemize">The DPJ erasure of <TT>int[]&lt;r1&gt;[]&lt;r2&gt;</TT> is <TT>int[][]</TT>.
<LI CLASS="li-itemize">The DPJ erasure of <TT>int[]&lt;[i]&gt;#i[]&lt;[i][j]&gt;#j</TT> is
 <TT>int[][]</TT>.
<LI CLASS="li-itemize">The DPJ erasure of <TT>C&lt;[_]&gt;[]&lt;[_]&gt;</TT> is <TT>C[]</TT>.
</UL>
<!--TOC subsection 4.3&nbsp;&nbsp;Typing Expressions-->

<H3 CLASS="subsection"><A NAME="htoc44">4.3</A>&nbsp;&nbsp;Typing Expressions<A NAME="sec:types:exp"></A></H3><!--SEC END -->

<!--NAME typing.exp.html-->
<BR>
<BR>
In Java, every expression has a type. For example, if a method
returns <TT>int</TT>, then an expression invoking that method has type
<TT>int</TT>. (Some statements have types too, but those statements
always enclose expressions.) The types allow the compiler to enforce
consistency of assignments; for example, to make sure that an
<TT>int</TT> is never assigned to a variable of type <TT>String</TT>.<BR>
<BR>
In DPJ, every expression has a type and an effect.
§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A> discusses the effects of statements and
expressions. Here we discuss DPJ's extensions to Java's rules for
determinining the type of an expression.<BR>
<BR>
<!--TOC subsubsection 4.3.1&nbsp;&nbsp;Field Access-->

<H4 CLASS="subsubsection"><A NAME="htoc45">4.3.1</A>&nbsp;&nbsp;Field Access<A NAME="sec:types:exp:field"></A></H4><!--SEC END -->

<!--NAME types.exp.field.html-->
<BR>
<BR>
A field access expression in Java has the general form
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><EM>selector-exp</EM><TT>.</TT><EM>field-name</EM>
</DL>
where <EM>selector-exp</EM> is a selector expression of class type <I>C</I>,
and <EM>field-name</EM> is the name of a field of class <I>C</I> (or a
superclass of <I>C</I>). If a bare field name appears, it is equivalent to
<TT>this.</TT><EM>field-name</EM>. Here we give the rules for the general
form.<BR>
<BR>
The compiler carries out the following steps to determine the type of
an expression <EM>selector-exp</EM><TT>.</TT><EM>field-name</EM>:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Determine the type <EM>selector-type</EM> of <EM>selector-exp</EM>, using the rules in
 this section together with the ordinary rules for Java types.
<LI CLASS="li-enumerate">Look up the type <EM>field-type</EM> of <TT>field</TT> based on the
 class <I>C</I> named in <EM>selector-type</EM>.
<LI CLASS="li-enumerate">Compute the <EM>capture</EM> (§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>) of
 <EM>selector-type</EM> to generate the type
 <EM>captured-selector-type</EM>.
<LI CLASS="li-enumerate">Make the following subsitutions in <EM>field-type</EM> to generate
 the answer:
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Substitute the type and RPL arguments of
 <EM>captured-selector-type</EM> for the corresponding type and RPL
 parameters of class <I>C</I>.
<LI CLASS="li-enumerate">If <EM>selector-exp</EM> is a <TT>final</TT> local variable or
 <TT>this</TT>, then substitute the variable for <TT>this</TT>. Otherwise,
 substitute a capture parameter (§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>)
 included in <EM>owner-rpl</EM><TT>:*</TT>, where <EM>owner-rpl</EM> is the
 owner RPL of the variable (§&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>).
</OL>
</OL>
Here is some example code for which the capture in step 3 is a no-op,
and the capture in step 4(b) isn't needed.
§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A> gives examples involving capture.

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>class</B> FieldTypingExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
<FONT SIZE=2>   2</FONT>     <FONT COLOR="blue"><B>region</B></FONT> r;
<FONT SIZE=2>   3</FONT>     FieldTypingExample&lt;R&gt; field1 <FONT COLOR="blue"><B>in</B></FONT> R;
<FONT SIZE=2>   4</FONT>     <B>void</B> FieldTypingExample&lt;r&gt; method1() {
<FONT SIZE=2>   5</FONT>         <B>return</B> (<B>new</B> FieldTypingExample&lt;r&gt;).field1;
<FONT SIZE=2>   6</FONT>     }
<FONT SIZE=2>   7</FONT>     FieldTypingExample&lt;<B>this</B>&gt; field2 <B><FONT COLOR="blue">in</FONT> this</B>;
<FONT SIZE=2>   8</FONT>     <B>void</B> FieldTypingExample&lt;arg&gt;
<FONT SIZE=2>   9</FONT>       method2(<B>final</B> FieldTypingExample&lt;R&gt; arg) {
<FONT SIZE=2>  10</FONT>         <B>return</B> arg.field;
<FONT SIZE=2>  11</FONT>     }
<FONT SIZE=2>  12</FONT> }</TT></DIV><BR>
<BR>
Let's see how to compute the type of the expression in the
<TT>return</TT> statement in line 5. Step 1: The selector is a <TT>new</TT>
expression of type <TT>FieldTypingExample&lt;r&gt;</TT>. Step 2: The field
name is <TT>field1</TT>, the class <I>C</I> is <TT>FieldTypingExample</TT>, and
the declared type of the field is <TT>FieldTypingExample&lt;R&gt;</TT> (line
3). Step 3: Nothing to do (see §&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>). Step
4: Substituting <TT>r</TT> given in the selector type expression for
<TT>R</TT> in the field type, we have that the answer is
<TT>FieldTypingExample&lt;r&gt;</TT>.<BR>
<BR>
Now let's see how to compute the type of the expression in the
<TT>return</TT> statement in line 10. Step 1: The selector is <TT>arg</TT>,
which has type <TT>FieldTypingExample&lt;R&gt;</TT>. Step 2: Now the field is
<TT>field2</TT>, and its type is <TT>FieldTypingExample&lt;this&gt;</TT> (line 7).
Step 3: Again, nothing to do. Step 4: <TT>arg</TT> is a <TT>final</TT>
local variable (line 9), so we can substitute it for <TT>this</TT> in the
type of <TT>field2</TT>. Therefore the answer is
<TT>FieldTypingExample&lt;arg&gt;</TT>.<BR>
<BR>
<!--TOC subsubsection 4.3.2&nbsp;&nbsp;Array Access-->

<H4 CLASS="subsubsection"><A NAME="htoc46">4.3.2</A>&nbsp;&nbsp;Array Access<A NAME="sec:types:exp:array"></A></H4><!--SEC END -->

<!--NAME sec:types:exp:array-->
<BR>
<BR>
An array access expression has the form
<EM>array-exp</EM><TT>[</TT><EM>index-exp</EM><TT>]</TT>, where <EM>array-exp</EM>
is an expression of array type, and <EM>index-exp</EM> is an expression
of integer type. To compute the type of this kind of expression, the
compiler does the following:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Compute the element type of the array type by deleting the
 leftmost pair of brackets, RPL argument if any, and index variable
 declaration, if any. For example, the element type of
 <TT>Data&lt;[_]&gt;[]&lt;[_]&gt;</TT> is <TT>Data&lt;[_]&gt;</TT>; the element type of
 <TT>int[]&lt;R1&gt;[]&lt;R2&gt;</TT> is <TT>int[]&lt;R2&gt;</TT>; and the element type of
 <TT>int[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j</TT> is <TT>int[]&lt;[i]:[j]&gt;#j</TT>.
<LI CLASS="li-enumerate">Substitute <EM>index-exp</EM> for the leftmost index variable in
 the element type to generate the answer. For example, if <TT>A</TT>
 has type <TT>Data&lt;[_]&gt;[]&lt;[_]&gt;</TT>, then expression <TT>A[0]</TT> has
 type <TT>Data&lt;[0]&gt;</TT>. If <TT>A</TT> has type <TT>int[]&lt;R1&gt;[]&lt;R2&gt;</TT>,
 then expression <TT>A[i]</TT> has type <TT>int[]&lt;R2&gt;</TT>. (Notice there
 is no substitution, because the index variable doesn't appear in the
 element type.) If <TT>A</TT> has type
 <TT>int[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j</TT>, then expression <TT>A[0]</TT> has
 type <TT>int[]&lt;[0]:j&gt;#j</TT>.
</OL>
<!--TOC subsubsection 4.3.3&nbsp;&nbsp;Method Invocation-->

<H4 CLASS="subsubsection"><A NAME="htoc47">4.3.3</A>&nbsp;&nbsp;Method Invocation<A NAME="sec:types:exp:invoke"></A></H4><!--SEC END -->

<!--NAME types.exp.invoke.html-->
<BR>
<BR>
<B>Explicit type and RPL arguments:</B> To compute the type of a
method invocation expression
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><EM>selector-exp</EM><TT>.&lt;</TT><EM>type-args</EM><TT>,</TT><EM>rpl-args</EM><TT>&gt;</TT><EM>method-name</EM><TT>(</TT><EM>args</EM><TT>)</TT>
</DL>
The compiler carries out the following steps:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Determine the type <EM>selector-type</EM> of <EM>selector-type</EM>
 and the types <EM>arg-types</EM> of <EM>args</EM>, using the rules in
 this section together with the ordinary rules for Java types.
<LI CLASS="li-enumerate">Look up the method in the ordinary Java way, using the method
 name, <EM>selector-type</EM>, and <EM>arg-types</EM>. Use the method to
 find formal value parameter types and return type.
<LI CLASS="li-enumerate">Compute the <EM>capture</EM> (§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>) of
 <EM>selector-type</EM> to generate the type
 <EM>captured-selector-type</EM>.
<LI CLASS="li-enumerate">Make the following substitutions in each of the formal argument
 types then check that the actual argument types <EM>arg-types</EM> are
 assignable (§§&nbsp;<A HREF="#sec:types:class:compare">4.1.2</A>
 and&nbsp;<A HREF="#sec:types:array:compare">4.2.4</A>) to the formal argument types:
<OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
Substitute the type and RPL arguments of
 <EM>captured-selector-type</EM> for the type and RPL arguments of its
 class.
<LI CLASS="li-enumerate">Substitute <EM>type-args</EM> and <EM>rpl-args</EM> for the type and
 RPL parameters of the method.
<LI CLASS="li-enumerate">For every argument in <EM>args</EM> of a type assignable to
 <TT>int</TT>, substitute the actual argument expression for the
 corresponding formal parameter of the method.
<LI CLASS="li-enumerate">If <EM>selector-exp</EM> is a <TT>final</TT> local variable or
 <TT>this</TT>, then substitute the variable for <TT>this</TT>. Otherwise
 substitute a capture parameter (§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>)
 included in <EM>owner-rpl</EM><TT>:*</TT>, where <EM>owner-rpl</EM> is the
 owner RPL of the variable (§&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>).
</OL>
<LI CLASS="li-enumerate">Make the same substitutions as in step 4 in the return type to
 compute the answer.
</OL>
Here is some example code for which the capture in step 3 is a no-op,
and the capture in step 4(d) isn't needed.
§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A> gives examples involving capture.

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>abstract class</B> MethodInvocationExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R1, R2&gt; {
<FONT SIZE=2>   2</FONT>     <B>abstract</B> &lt;<FONT COLOR="blue"><B>region</B></FONT> R3&gt;
<FONT SIZE=2>   3</FONT>         MethodInvocationExample&lt;R3, [i]&gt;callee(<B>int</B> i);
<FONT SIZE=2>   4</FONT>     MethodInvocationExample&lt;Root, [0]&gt;caller() {
<FONT SIZE=2>   5</FONT>         <B>return this</B>.&lt;Root&gt;callee(0);
<FONT SIZE=2>   6</FONT>     }
<FONT SIZE=2>   7</FONT> }</TT></DIV>Lines 1&ndash;2 define a method <TT>callee</TT> with one RPL parameter
<TT>R3</TT> and one formal parameter <TT>int i</TT>. It returns type
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>MethodInvocationExample&lt;R3,[i]&gt;</TT>. 
</DL>
Notice that the return type is written in terms of the method
parameter (both the RPL and value parameter); these parameters have to
be substituted away to generate a meaningful type at the call site.<BR>
<BR>
At the call site (line 5), the compiler does the following. Step 1:
The selector type is 
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>MethodRegionInvocationExample&lt;R1,R2&gt;</TT>,
</DL>
and the argument type is <TT>int</TT>. Step 2: The invoked method is
<TT>callee</TT>, defined in lines 1&ndash;2. Step 3: Nothing to do (see
§&nbsp;<A HREF="#sec:types:exp:capture">4.3.4</A>). Step 4: Binding 0 to <TT>int</TT> is
OK. Step 5: The return type is
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>&lt;MethodInvocationExample&lt;R3,[i]&gt;</TT>.
</DL>
The method arguments are <TT>R3</TT>=<TT>Root</TT> and <TT>i</TT>=0.
Substituting arguments for parameters gives a return type of
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>MethodInvocationExample&lt;Root,[0]&gt;</TT>.
</DL>
<B>Inferred type and RPL arguments:</B> If there are no explicit
type or RPL arguments, the compiler infers them as discussed in
§&nbsp;<A HREF="#sec:classes:params:method">2.4.2</A> and proceeds as stated above, using
the inferred arguments in step 4(b). As in ordinary Java, if there is
no <EM>selector-exp</EM>, then the implied selector is <TT>this</TT>.<BR>
<BR>
<!--TOC subsubsection 4.3.4&nbsp;&nbsp;Captured Types-->

<H4 CLASS="subsubsection"><A NAME="htoc48">4.3.4</A>&nbsp;&nbsp;Captured Types<A NAME="sec:types:exp:capture"></A></H4><!--SEC END -->

<!--NAME types.exp.capture.html-->
<BR>
<BR>
The <EM>capture</EM> of a generic type is important in generic Java; it
prevents bad assignments through wildcard types. DPJ uses the same
concept in connection with partially-specified RPLs, which are a kind
of wildcard, as they can stand in for several different regions. To
motivate the problem, consider this example:

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>class</B> CaptureExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
<FONT SIZE=2>   2</FONT>     CaptureExample&lt;R&gt; field;
<FONT SIZE=2>   3</FONT>     <B>void</B> method() {
<FONT SIZE=2>   4</FONT>         <FONT COLOR="blue"><B>region</B></FONT> r1, r2;
<FONT SIZE=2>   5</FONT>         <FONT COLOR="fuchsia"><EM>// Create a new CaptureExample&lt;R:r1&gt;</EM></FONT>
<FONT SIZE=2>   6</FONT>         CaptureExample&lt;R:r1&gt; ce = <B>new</B> CaptureExample&lt;R:r1&gt;();
<FONT SIZE=2>   7</FONT>         <FONT COLOR="fuchsia"><EM>// Assign it to CaptureExample&lt;R:*&gt;; this is allowed</EM></FONT>
<FONT SIZE=2>   8</FONT>         CaptureExample&lt;R:*&gt; ceStar = ce;
<FONT SIZE=2>   9</FONT>         <FONT COLOR="fuchsia"><EM>// This should not be allowed!</EM></FONT>
<FONT SIZE=2>  10</FONT>         ceStar.field = <B>new</B> CaptureExample&lt;R:r2&gt;();
<FONT SIZE=2>  11</FONT>     }
<FONT SIZE=2>  12</FONT> }</TT></DIV>The assignment in line 10 is a problem: the <EM>actual</EM> type of the
object stored in <TT>ceStar</TT> is <TT>CaptureExample&lt;R:r1&gt;</TT>. That's
because the assignment in line 8 didn't change the type of the object;
it just assigned the same object to a different reference with a
partially specified type. So the actual type of the <TT>field</TT> field
of that object is <TT>CaptureExample&lt;R:r1&gt;</TT>. That means it can't
hold a <TT>CaptureExample&lt;R:r2&gt;</TT>; that would violate the consistency
of typing at runtime. However, the type of the selector <TT>ceStar</TT>
is <TT>CaptureExample&lt;R:*&gt;</TT>. If we computed the type of
<TT>ceStar.field</TT> by just substituting the actual for formal
arguments in the selector type, we would get <TT>CaptureExample&lt;R:*&gt;</TT>
for the type of <TT>ceStar.field</TT>, and the bad assignment would be
allowed.<BR>
<BR>
So we don't do that. Instead, we introduce a new parameter, called a
<EM>capture parameter</EM>, in the type of the selector. It stands in
for the unknown actual region of an object stored in a variable with
partially specified type. The introduction of the new parameter is
called <EM>capturing</EM> a type. It occurs in steps 3 and 4(b) of
typing field access (§&nbsp;<A HREF="#sec:types:exp:field">4.3.1</A>) and steps 3 and
4(d) of typing method invocation (§&nbsp;<A HREF="#sec:types:exp:invoke">4.3.3</A>).<BR>
<BR>
In this example, the captured type of the selector is
<TT>CaptureExample&lt;P&gt;</TT>, where <TT>P</TT> is the capture parameter.
<TT>P</TT> is constrained to be included in <TT>R:*</TT>, because that is
all we know about the actual region from the type
<TT>CaptureExample&lt;R:*&gt;</TT>. This is the only way parameters can be
inclusion-constrained in DPJ (§&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>).
In the example above, now the bad assignment is disallowed, because
the type <TT>CaptureExample&lt;R:r2&gt;</TT> is not assignable to the type
<TT>CaptureExample&lt;P&gt;</TT>, where <TT>P</TT> is the capture parameter. Nor
is the type <TT>CaptureExample&lt;R:*&gt;</TT> assignable to
<TT>CaptureExample&lt;P&gt;</TT>. However, <TT>CaptureExample&lt;P&gt;</TT> is
assignable to <TT>CaptureExample&lt;R:*&gt;</TT>, because of the inclusion
constraint.<BR>
<BR>
More generally, this is how the compiler computes the capture of a type
in DPJ:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Take the normal Java capture of the type, substituting for any
 wildcard generic type arguments but keeping the same RPL
 arguments, if any.
<LI CLASS="li-enumerate">For each RPL that is partially specified (i.e., contains <TT>*</TT>
 or <TT>[?]</TT>), replace that RPL with a capture parameter constrained
 to be included in the RPL.
</OL>
Notice that if there are no generic wildcards and no partially
specified RPL arguments, then the capture operation does nothing to
the type.<BR>
<BR>
Capturing types is mostly an internal compiler mechanism. Programmers
never have to do it, and they shouldn't even have to worry about it,
except to deal with capture errors when they occur. For example, the
above code, if compiled, would generate a type error like &#8220;expected
type <TT>CaptureExample&lt;capture of R:*&gt;</TT>, found type
<TT>CaptureExample&lt;R:r2&gt;</TT>.&#8221; That error will probably be mysterious
unless you understand how type capture works.<BR>
<BR>
Here is another common way that capture errors can occur, involving
method invocations:

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>abstract class</B> CaptureMethodExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
<FONT SIZE=2>   2</FONT>     <B>abstract void</B> callee(CaptureMethodExample&lt;R&gt; x);
<FONT SIZE=2>   3</FONT>     <B>void</B> caller(CaptureMethodExample&lt;*&gt; y) {
<FONT SIZE=2>   4</FONT>         <FONT COLOR="fuchsia"><EM>// Compile error!</EM></FONT>
<FONT SIZE=2>   5</FONT>         y.callee(y);
<FONT SIZE=2>   6</FONT>     }
<FONT SIZE=2>   7</FONT> }</TT></DIV>Line 4 causes an error, because it is attempting to assign <TT>y</TT>,
which has type 
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>CaptureMethodExample&lt;*&gt;</TT> 
</DL>
to type 
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>CaptureMethodExample&lt;capture of *&gt;</TT>
</DL>
which is the type of the formal parameter <TT>x</TT> of <TT>callee</TT>,
after capturing the selector type.<BR>
<BR>
Usually you can work around these errors by adding a parameter. For
example, the code above could be rewritten as follows:

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>abstract class</B> CaptureMethodExample&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
<FONT SIZE=2>   2</FONT>     <B>abstract void</B> callee(CaptureMethodExample&lt;R&gt; x);
<FONT SIZE=2>   3</FONT>     &lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> caller(CaptureMethodExample&lt;R&gt; y) {
<FONT SIZE=2>   4</FONT>         <FONT COLOR="fuchsia"><EM>// OK</EM></FONT>
<FONT SIZE=2>   5</FONT>         y.callee(y);
<FONT SIZE=2>   6</FONT>     }
<FONT SIZE=2>   7</FONT> }
<FONT SIZE=2>   8</FONT> %</TT></DIV>By adding a method region parameter <TT>R</TT>, we &#8220;capture the type
ourselves.&#8221; Now the code explicitly says that the region in the type
of <TT>y</TT> is the same as the region of the type of <TT>x</TT>: whatever
it is, it is bound to the same parameter <TT>R</TT> in both cases.<BR>
<BR>

<!--TOC section 5&nbsp;&nbsp;Effects-->

<H2 CLASS="section"><A NAME="htoc49">5</A>&nbsp;&nbsp;Effects<A NAME="sec:effects"></A></H2><!--SEC END -->

<!--NAME effects.html-->
<BR>
<BR>
Effects are the way that DPJ tracks accesses to the heap to enforce
determinism. An effect is an action that reads or writes memory.
Every statement and expression in the program is assigned an effect.
If the effects of two statements do not interfere, then the statements
may be safely run in parallel. Effects don't interfere if neither one
writes to memory, or they operate on different parts of memory, or
they are both invocations of a method declared <TT>commutative</TT>
(§&nbsp;<A HREF="#sec:classes:methods:commutative">2.3.4</A>).<BR>
<BR>
This section describes how effects work in DPJ.
§&nbsp;<A HREF="#sec:effects:basic">5.1</A> describes <EM>basic effects</EM>, which are
individual actions involving memory (such as reading or writing a
variable). §&nbsp;<A HREF="#sec:effects:summaries">5.2</A> describes <EM>effect
 summaries</EM>, which are the program representation of sets of basic
effects, and are used to summarize the effects of methods.
§&nbsp;<A HREF="#sec:effects:local">5.3</A> describes <EM>local effects</EM>, which are
effects inside a method that are not visible to the caller and so may
be omitted from the method's effect summary.
§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A> explains how DPJ statements and
expressions generate basic effects. §&nbsp;<A HREF="#sec:effects:coarsening">5.5</A>
describes <EM>effect coarsening</EM>, which is necessary for summarizing
effects on RPLs and local variables that can go out of scope.
§&nbsp;<A HREF="#sec:effects:subeffects">5.6</A> explains the <EM>subeffect</EM> relation
on effects, which is important for checking method effect summaries
against the actual method effects. §&nbsp;<A HREF="#sec:effects:nonint">5.7</A>
explains the <EM>noninterference</EM> relation on effects, which is
important for checking that pairs of parallel tasks have no
conflicting operations.<BR>
<BR>
<!--TOC subsection 5.1&nbsp;&nbsp;Basic Effects-->

<H3 CLASS="subsection"><A NAME="htoc50">5.1</A>&nbsp;&nbsp;Basic Effects<A NAME="sec:effects:basic"></A></H3><!--SEC END -->

<!--NAME effects.basic.html-->
<BR>
<BR>
A basic effect is an action involving memory. DPJ's effect system
represents the following kinds of effects:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<EM>Read effects:</EM> A read effect indicates a read operation on
 an RPL (§&nbsp;<A HREF="#sec:rpls">3</A>) or local variable. Such an effect
 summarizes one or more reads to one or more memory locations
 associated with the region or regions named by the RPL.
<LI CLASS="li-enumerate"><EM>Write effects:</EM> A write effect indicates a write operation
 on an RPL (§&nbsp;<A HREF="#sec:rpls">3</A>) or local variable. Such an effect
 summarizes one or more writes <EM>or reads</EM> to one or more memory
 locations associated with the region or regions named by the RPL.
<LI CLASS="li-enumerate"><EM>Invocation effects:</EM> An invocation effects indicates an
 invocation of some method, causing some set of basic effects (the
 effects of invoking the method). The basic effects associated with
 the invocation are called the <EM>underlying effects</EM> of the
 invocation. For example, if method <TT>m</TT> has effect summary
 <TT>writes r</TT> (§&nbsp;<A HREF="#sec:effects:summaries">5.2</A>), then invoking
 <TT>m</TT> generates an invocation effect with <TT>m</TT> as its method
 and <TT>writes r</TT> as its underlying effect.
</OL>
Read and write effects on an RPL <I>R</I> are generated by directly
accessing a class field declared to be in <I>R</I>
(§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>) or an array cell in <I>R</I>
(§&nbsp;<A HREF="#sec:types:array">4.2</A>), or by invoking a method with the effect in
its effect summary (§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>).
Invocation effects are always generated by invoking methods.
§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A> gives more details on how DPJ statements
and expressions generate these effects.<BR>
<BR>
Invocation effects are necessary because some method invocations can
commute with others (§&nbsp;<A HREF="#sec:classes:methods:commutative">2.3.4</A>). To
keep track of these pairs of commuting methods, the compiler needs to
record the information about which method was invoked, in addition to
what effects the method invocation caused.<BR>
<BR>
Notice that effects on local variables (including method parameters)
are recorded separately from effects on RPLs. Because local variables
cannot have their references taken, and never alias, the compiler
automatically keeps track of interfering effects on local variables.
The programmer doesn't have to put them in RPLs or summarize their
effects.<BR>
<BR>
Finally, notice that a write effect can represent both reads and
writes. Writes are &#8220;stronger&#8221; than reads (for interference, at
least one of two operations to the same location must be a write), so
it is sound but conservative to represent reads as writes. In some
cases it may reduce the size of the effect set. For example, a read
and a write to the same location may be represented with just the
write effect. Finally, allowing write effects to represent reads does
not sacrifice any precision, since (1) a read to a location alone can
always be represented as a read effect; and (2) a read and write to a
location can always be represented as a single write to that location
without any loss of precision (the presence of the write already
causes any parallel access to the location to interfere, so the
presence or absence of the read makes no difference).<BR>
<BR>
<!--TOC subsection 5.2&nbsp;&nbsp;Effect Summaries-->

<H3 CLASS="subsection"><A NAME="htoc51">5.2</A>&nbsp;&nbsp;Effect Summaries<A NAME="sec:effects:summaries"></A></H3><!--SEC END -->

<!--NAME effects.summaries.html-->
<BR>
<BR>
An <EM>effect summary</EM> is a bit of program text that summarizes a
set of basic effects (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>). In the current DPJ
language, effect summaries can appear in the program text only in
method definitions, where they summarize the effects of invoking the
method (§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>). It is anticipated
that future versions of DPJ will also allow effect summaries to appear
as arguments to <EM>effect variables</EM> in class types and method
invocations, for greater flexibility in specifying and checking
effects.<BR>
<BR>
An effect summary consists of one of the following:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>pure</TT>, indicating no effect on the heap.
<LI CLASS="li-enumerate"><TT>reads</TT> <EM>rpl-list</EM>, indicating reads to the RPLs given
 in <EM>rpl-list</EM>.
<LI CLASS="li-enumerate"><TT>writes</TT> <EM>rpl-list</EM>, indicating writes <EM>or reads</EM>
 to the RPLs given in <EM>rpl-list</EM>. 
<LI CLASS="li-enumerate"><TT>reads</TT> <EM>rpl-list-1</EM> <TT>writes</TT> <EM>rpl-list-2</EM>,
 indicating both reads to the RPLs in <EM>rpl-list-1</EM> and writes to
 the RPLs in <EM>rpl-list-2</EM>.
</OL>
Currently there is no way to represent an invocation effect
(§&nbsp;<A HREF="#sec:effects:basic">5.1</A>) directly in an effect summary;
invocations in the method body must be summarized by giving their
underlying effects. This may change in future versions of DPJ.<BR>
<BR>
Here is a simple example of an effect summary:

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>class</B> Point&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
<FONT SIZE=2>   2</FONT>     <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R, y <FONT COLOR="blue"><B>in</B></FONT> R;
<FONT SIZE=2>   3</FONT>     &lt;<FONT COLOR="blue"><B>region</B></FONT> Rp&gt;<B>void</B> add(Point&lt;<FONT COLOR="blue"><B>region</B></FONT> Rp&gt; p)
<FONT SIZE=2>   4</FONT>       <FONT COLOR="blue"><B>reads</B></FONT> Rp <FONT COLOR="blue"><B>writes</B></FONT> R {
<FONT SIZE=2>   5</FONT>         <B>this</B>.x += p.x;
<FONT SIZE=2>   6</FONT>         <B>this</B>.y += p.y;
<FONT SIZE=2>   7</FONT>     }
<FONT SIZE=2>   8</FONT> }</TT></DIV>This class defines a simple <TT>Point</TT> object with integer
coordinates <TT>x</TT> and <TT>y</TT>. There is one class region parameter
<TT>R</TT> (§&nbsp;<A HREF="#sec:classes:params:class">2.4.1</A>), and the coordinate fields
are placed in the region of <TT>R</TT>. The <TT>add</TT> method takes a
<TT>Point</TT> object with some other (possibly different) region
<TT>Rp</TT> and adds the coordinates of that point to the coordinates of
this one. The summarized effects are <TT>reads Rp writes R</TT>, shown
in line 4, because the method reads the coordinates of <TT>p</TT> in
region <TT>Rp</TT> and writes the coordinates of <TT>this</TT> in region
<TT>R</TT>.<BR>
<BR>
<!--TOC subsection 5.3&nbsp;&nbsp;Local Effects-->

<H3 CLASS="subsection"><A NAME="htoc52">5.3</A>&nbsp;&nbsp;Local Effects<A NAME="sec:effects:local"></A></H3><!--SEC END -->

<!--NAME effects.local.html-->
<BR>
<BR>
A basic effect (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>) is <EM>local</EM> if it is a
read or write effect on a local variable or local RPL
(§&nbsp;<A HREF="#sec:rpls:local">3.5</A>), or it is an invocation effect whose
underlying effects are all local. Local effects are contained within
a method scope and never seen by the calling context, so they may be
ignored when summarizing method effects. For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> LocalEffects&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    <FONT COLOR="fuchsia"><EM>// method has no effects visible to the caller</EM></FONT>
    <B>void</B> method() <FONT COLOR="blue"><B>pure</B></FONT> {
        <FONT COLOR="blue"><B>region</B></FONT> r;
        <FONT COLOR="fuchsia"><EM>// Write effect on var is local</EM></FONT>
        LocalEffects&lt;r&gt; var = <B>new</B> LocalEffects&lt;r&gt;();
        <FONT COLOR="fuchsia"><EM>// Write effect on region r is local</EM></FONT>
        var.x = 5;
    }
}</TT></DIV><BR>
<BR>
<!--TOC subsection 5.4&nbsp;&nbsp;Effects of Statements and Expressions-->

<H3 CLASS="subsection"><A NAME="htoc53">5.4</A>&nbsp;&nbsp;Effects of Statements and Expressions<A NAME="sec:effects:stmt-exp"></A></H3><!--SEC END -->

<!--NAME effects.stmt-exp.html-->
<BR>
<BR>
At the heart of DPJ's determinism checking is an analysis of the
effect of every statement and expression in the program. To compute
the effects, the compiler uses the following information:
<UL CLASS="itemize"><LI CLASS="li-itemize">
The form of the expression or statement. For example,
 an assignment statements generates a write on the left-hand side,
 and a read on the right-hand side.
<LI CLASS="li-itemize">The type of a field access selector, method invocation selector,
 or array, together with the RPL of the field (for field access) or
 declared method efects (for method invocations). For example, if a
 class <TT>C&lt;region R&gt;</TT> has a field <TT>x in R</TT>, then access
 through a variable of type <TT>C&lt;r&gt;</TT> generates an effect on
 <TT>r</TT>. Similarly, if <TT>C</TT> has a method <TT>void m() writes
 R</TT>, then invoking <TT>m</TT> on a variable of type <TT>C&lt;r&gt;</TT>
 generates the effect <TT>writes r</TT>.
</UL>
The field region specifiers (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>)
are important because they effectively partition the class fields into
regions that can be used to describe the effects. The method effect
summaries (§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>) are important
because they (1) document the effects of methods at API boundaries
(including, e.g., methods in classes for which the source code is not
available); and (2) allow the compiler to infer the effect of a method
invocation from the summary, rather than doing an interprocedural
analysis. (Because method calls can be recursive, this analysis would
need to iterate to a fixed point.)<BR>
<BR>
In more detail, here is how the compiler computes the effects of a
DPJ statement or expression:<BR>
<BR>
<B>Field access:</B> For field access expressions
<EM>selector-exp</EM><TT>.</TT><EM>field-name</EM> that directly access a
non-<TT>final</TT> field, the compiler first computes the RPL accessed by
the expression. It uses the same procedure as for typing field access
(§&nbsp;<A HREF="#sec:types:exp:field">4.3.1</A>), except that it uses the RPL specifier
of the field (§&nbsp;<A HREF="#sec:classes:field-region-spec">2.2</A>) instead of the
type associated with the field, and there are no substitutions for
type parameters in step 4(a). The compiler records a write or read
effect (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>) to the RPL so computed, depending
on whether the expression appears on the left-hand side of an
assignment, or in a read access.<BR>
<BR>
Reads of fields declared <TT>final</TT> generate no effect (writes, other
than initialization, are not allowed). Because the value of
a <TT>final</TT> field does not change after initialization, reading it
cannot cause a conflicting access.<BR>
<BR>
<B>Array access:</B> For array access expressions <TT><I>e</I><SUB>1</SUB>[<I>e</I><SUB>2</SUB>]</TT>
that access an array cell, the compiler first computes the RPL of the
cell. To do this it substitutes <I>e</I><SUB>2</SUB> for the leftmost index variable
in the leftmost RPL argument appearing in the type of <I>e</I><SUB>1</SUB>. For
example, if array <TT>A</TT> has type <TT>int[]&lt;[_]&gt;</TT>, then the RPL
accessed by <TT>A[0]</TT> is <TT>[i]</TT>; and if array <TT>B</TT> has type
<TT>int[]&lt;[i]&gt;#i[]&lt;[i]:[j]&gt;#j</TT>, then the RPL accessed by <TT>B[0]</TT>
is <TT>[0]</TT>. The compiler records a write or read effect to the RPL
so computed, depending on whether the array access expression appears
on the left-hand side of an assignment, or in a read access.<BR>
<BR>
Note that access through multiple dimensions of an array of arrays
causes a read effect for all but the last dimension. For example, for
array <TT>B</TT> defined above, the effect of expression <TT>B[0][1]</TT> is
a read of <TT>[0]</TT>, plus a either a read or write on <TT>[0]:[1]</TT>,
depending on the context. For example, <TT>x = B[0][1]</TT> generates a
read, while <TT>B[0][1] = x</TT> generates a write. In fact, this is
just a special case of the rules stated in the previous paragraph,
together with the rules for compound expressions (see below).<BR>
<BR>
<B>Method invocation:</B> For method invocation expressions, the
compiler computes and accumulates the effects of evaluating the
selector and argument expressions as described in this section. Then
it uses the method's effect summary
(§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>) to compute the effect of the
invocation itself. It uses the same procedure as for computng the
return type of a method (§&nbsp;<A HREF="#sec:types:exp:invoke">4.3.3</A>), except that
it uses the effect summary instead of the declared return type, and
there are no substitutions for type parameters in steps 4(a) or 4(b).
The compiler records an invocation effect (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>)
with the invoked method and the computed effect.<BR>
<BR>
<B>Local variable access:</B> For statements and expressions that
access a non-<TT>final</TT> local variable (i.e., variable declared in a
method scope or method formal parameter), the compiler records a read
or write effect on the variable. Effects on <TT>final</TT> local
variables are ignored.<BR>
<BR>
<B>Compound statements and expressions:</B> For any statement or
expression made up of other statements or expressions (including, for
example, an assignment that has a method invocation on its right-hand
side, or an array access to an expression which is itself an array
access), the compiler accumulates the effect of the components,
coarsening component effects as necessary
(§&nbsp;<A HREF="#sec:effects:coarsening">5.5</A>) to remove elements that are no
longer in scope at the outer level.<BR>
<BR>
<!--TOC subsection 5.5&nbsp;&nbsp;Effect Coarsening-->

<H3 CLASS="subsection"><A NAME="htoc54">5.5</A>&nbsp;&nbsp;Effect Coarsening<A NAME="sec:effects:coarsening"></A></H3><!--SEC END -->

<!--NAME effects.coarsening.html-->
<BR>
<BR>
A statement or expression may generate an effect that is no longer in
scope where the effect must be reported. For example, consider the
following <TT>foreach</TT> loop (§&nbsp;<A HREF="#sec:parallel:foreach">6.2</A>) on an
index-parameterized array (§&nbsp;<A HREF="#sec:types:array:ipa">4.2.2</A>):

 <DIV CLASS="numbereddpjlisting"><TT><FONT SIZE=2>   1</FONT> <B>int</B>[]&lt;[_]&gt; A = <B>new int</B>[N]&lt;[_]&gt;;
<FONT SIZE=2>   2</FONT> <FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, N) {
<FONT SIZE=2>   3</FONT>     A[i] = i;
<FONT SIZE=2>   4</FONT> }</TT></DIV>In line 3, the effect is <TT>writes [i]</TT>. But what is the effect in
the scope outside the loop? This is important, for example, if this
code appears inside a method body and its effect must be summarized.
We can solve this problem with partially-specified RPLs
(§&nbsp;<A HREF="#sec:rpls:partial">3.4</A>). For example, the effect <TT>writes [?]</TT>
covers all the effects <TT>writes [i]</TT> for all <TT>i</TT> inside the
loop, so that is what we use. This is called <EM>effect
 coarsening</EM>.<BR>
<BR>
<B>Coarsening of local effects:</B> An effect on a local RPL
(§&nbsp;<A HREF="#sec:rpls:local">3.5</A>) or local variable is simply deleted from the
effect set when the RPL or variable goes out of scope. For example,
in the following code fragment, neither block contained in the
<TT>cobegin</TT> has any effect:

 <DIV CLASS="dpjlisting"><TT><B>class</B> LocalEffectCoarsening&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    <B>void</B> method() <FONT COLOR="blue"><B>pure</B></FONT> {
        <FONT COLOR="blue"><B>cobegin</B></FONT> {
            <FONT COLOR="fuchsia"><EM>// No effect here because var1 and r1 are out of scope</EM></FONT>
            {
                <FONT COLOR="blue"><B>region</B></FONT> r1;
                LocalEffectCoarsening&lt;r1&gt; var1 =
                    <B>new</B> LocalEffectCoarsening&lt;r1&gt;();
                var1.x = 10;
            }
            <FONT COLOR="fuchsia"><EM>// No effect here either because var2 and r2 are out of
            // scope</EM></FONT>
            {
                <FONT COLOR="blue"><B>region</B></FONT> r2;
                LocalEffectCoarsening&lt;r2&gt; var2 =
                    <B>new</B> LocalEffectCoarsening&lt;r2&gt;();
                var2.x = 25;
            }
        }
    }
}</TT></DIV><BR>
<BR>
This pattern can also be used effectively with <TT>foreach</TT>, by
having each iteration create its own objects whose effects are
invisible to the other iterations:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, N) {
    <FONT COLOR="fuchsia"><EM>// r is local to a foreach iteration</EM></FONT>
    <FONT COLOR="blue"><B>region</B></FONT> r;
    <FONT COLOR="fuchsia"><EM>// Do some effects on r</EM></FONT>
    ...
}</TT></DIV>This technique is useful for creating private objects in each
iteration that manipulate data local to that iteration. See
<EM>The Deterministic Parallel Java Tutorial</EM> for more examples.<BR>
<BR>
<B>Coarsening of nonlocal effects:</B> Coarsening of nonlocal
effects works as follows.<BR>
<BR>
<I>Variable RPLs:</I> An effect on an RPL starting with a
<TT>final</TT> local variable
(§§&nbsp;<A HREF="#sec:rpls:basic:var">3.1.5</A>,&nbsp;<A HREF="#sec:rpls:sequences">3.2</A>) is coarsened
when the variable goes out of scope. The effect is replaced by a new
effect on <EM>owner-rpl</EM><TT>:*</TT>, where <EM>owner-rpl</EM> is the
owner RPL of the variable's type (§&nbsp;<A HREF="#sec:types:class:owner-rpl">4.1.4</A>).
Because variables may be nested under variables, this operation is
performed recursively on the resulting RPL until an RPL is obtained
that is valid in the outer scope.<BR>
<BR>
For example:

 <DIV CLASS="dpjlisting"><TT><B>class</B> VariableCoarsening&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>int</B> x <FONT COLOR="blue"><B>in</B></FONT> R;
    <B>void</B> method() <FONT COLOR="blue"><B>writes</B></FONT> R:* {
        <FONT COLOR="fuchsia"><EM>// Coarsened effect is 'writes R:*'</EM></FONT>
        {
            <B>final</B> VariableCoarsening&lt;R&gt; vc1 =
                <B>new</B> VariableCoarsening&lt;R&gt;();
            VariableCoarsening&lt;vc1&gt; vc2 =
                <B>new</B> VariableCoarsening&lt;vc1&gt;();
            <FONT COLOR="fuchsia"><EM>// Effect is 'writes vc1'</EM></FONT>
            vc2.x = 5;
    }
}</TT></DIV><BR>
<BR>
Note that method parameters are in scope in the method definition, so
effects on method parameter RPLs don't need to be coarsened in the
method's effects:

 <DIV CLASS="dpjlisting"><TT><B>abstract class</B> ParamRPLs&lt;<FONT COLOR="blue"><B>region</B></FONT> R&gt; {
    <B>abstract void</B> method(ParamRPLs&lt;R&gt; param)
        <FONT COLOR="fuchsia"><EM>// OK; 'writes R:*' is also OK, but less precise</EM></FONT>
        <FONT COLOR="blue"><B>writes</B></FONT> param;
}</TT></DIV><BR>
<BR>
<I>Array index RPLs:</I> An effect on an RPL containing the array
index <TT>[<I>e</I>]</TT> is coarsened to <TT>[?]</TT> if the expression <I>e</I>
includes an integer variable that goes out of scope. An example is
the <TT>foreach</TT> code given at the beginning of this section.<BR>
<BR>
<!--TOC subsection 5.6&nbsp;&nbsp;Subeffects-->

<H3 CLASS="subsection"><A NAME="htoc55">5.6</A>&nbsp;&nbsp;Subeffects<A NAME="sec:effects:subeffects"></A></H3><!--SEC END -->

<!--NAME effects.subeffects.html-->
<BR>
<BR>
The subeffect relation determines whether one set of effects covers
another set of effects, i.e., all effects in the second set are
represented in the first set. The compiler uses the subeffect
relation to check that a method's declared effects
(§&nbsp;<A HREF="#sec:classes:methods:summaries">2.3.1</A>) include the actual effects of
its body and the effects of any overriding methods.<BR>
<BR>
<B>Basic effects:</B> The following rules determine when one basic
effect (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>) is a subeffect of another:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If one RPL is included in another
 (§&nbsp;<A HREF="#sec:rpls:comparing:include">3.6.3</A>), then a read of the first RPL
 is a subeffect of a read or write to the second. For example,
 <TT>reads Root</TT> is a subeffect of <TT>reads Root:*</TT> and
 <TT>writes Root:*</TT>.
<LI CLASS="li-itemize">If one RPL is included in another, then a write to the first RPL
 is a subeffect of a write to the second. For example, <TT>writes
 Root</TT> is a subeffect of <TT>writes Root:*</TT>. Note that
 <TT>writes Root</TT> is <EM>not</EM> a subeffect of <TT>reads Root:*</TT>.
<LI CLASS="li-itemize">An invocation of method <I>m</I> with underlying effect set <I>E</I><SUB>1</SUB> is
 a subeffect of an invocation of method <I>m</I> with underlying effect
 set <I>E</I><SUB>2</SUB> if <I>E</I><SUB>1</SUB> is a subeffect of <I>E</I><SUB>2</SUB>. For example, an
 invocation of <I>m</I> with underlying effect <TT>writes R</TT> is a
 subeffect of an invocation of <I>m</I> with underlying effect <TT>writes
 R:*</TT>.
</UL>
<B>Effect sets:</B> The following rules determine when one set of
basic effects is a subeffect of another:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If each basic effect in one set is a subeffect of some basic
 effect in the another set, then the first set is a subeffect of the
 second. For example, <TT>reads A writes B</TT> is a subeffect
 <TT>writes A:*, B:*</TT>, because <TT>reads A</TT> is a subeffect of
 <TT>writes A:*</TT>, and <TT>writes B</TT> is a subeffect of <TT>writes
 B:*</TT>.
<LI CLASS="li-itemize">An invocation effect is a subeffect of its underlying effect.
 For example, an invocation of method <I>m</I> with the effect <TT>writes
 R</TT> is a subeffect of <TT>writes R</TT>. This means that invocations
 may always be summarized by stating their underlying effects.
</UL>
<!--TOC subsection 5.7&nbsp;&nbsp;Noninterference of effect-->

<H3 CLASS="subsection"><A NAME="htoc56">5.7</A>&nbsp;&nbsp;Noninterference of effect<A NAME="sec:effects:nonint"></A></H3><!--SEC END -->

<!--NAME effects.nonint.html-->
<BR>
<BR>
The noninterference relation on effects determines whether two sets of
effects are safe to be run in parallel. The compiler uses the
noninterference relation to check that there are no conflicting
effects in mutually parallel tasks (§&nbsp;<A HREF="#sec:parallel">6</A>).<BR>
<BR>
<B>Basic effects:</B> The following rules determine when one basic
effect (§&nbsp;<A HREF="#sec:effects:basic">5.1</A>) is a subeffect of another:
<UL CLASS="itemize"><LI CLASS="li-itemize">
Two basic effects are noninterfering if they are both read
 effects.
<LI CLASS="li-itemize">Two basic effects are noninterfering if they are each read or
 write effects, and they operate on disjoint RPLs
 (§&nbsp;<A HREF="#sec:rpls:comparing:disjoint">3.6.4</A>).
<LI CLASS="li-itemize">Two invoke effects are noninterfering if they invoke the same
 method, and the method is declared <TT>commutative</TT>
 (§&nbsp;<A HREF="#sec:classes:methods:commutative">2.3.4</A>).
</UL>
<B>Effect sets:</B> The following rules determine when one effect
set is a subeffect of another:
<UL CLASS="itemize"><LI CLASS="li-itemize">
If every basic effect in one set is noninterfering with every
 basic effect in another set, then the two sets are noninterfering.
 For example, <TT>reads A writes B</TT> is noninterfering with
 <TT>writes C,D</TT>. However, <TT>reads A writes B</TT> is interfering
 with <TT>writes A,C</TT>, because <TT>reads A</TT> inteferes with
 <TT>writes A</TT>.
<LI CLASS="li-itemize">If two effect sets are each a subeffect of another effect set,
 and the including sets are noninterfering, then the included sets
 are noninterfering. In particular, two invoke effects are
 noninterfering if their underlying effects are (because the
 underlying effects include the invoke effects, see
 §&nbsp;<A HREF="#sec:effects:subeffects">5.6</A>).
</UL>

<!--TOC section 6&nbsp;&nbsp;Parallel Control Flow-->

<H2 CLASS="section"><A NAME="htoc57">6</A>&nbsp;&nbsp;Parallel Control Flow<A NAME="sec:parallel"></A></H2><!--SEC END -->

<!--NAME parallel.html-->
<BR>
<BR>
DPJ employs a fork-join model of parallelism. That means that a task
may launch several parallel tasks (the fork) and all must complete
(the join) before the launching task can continue. Recursive forking
is supported, i.e., tasks can launch other tasks to arbitrary depth.
There are two ways to fork tasks: <TT>cobegin</TT>, which forks several
statements as parallel tasks, and <TT>foreach</TT>, which forks groups of
consecutive loop iterations as parallel tasks.<BR>
<BR>
<!--TOC subsection 6.1&nbsp;&nbsp;<TT>cobegin</TT>-->

<H3 CLASS="subsection"><A NAME="htoc58">6.1</A>&nbsp;&nbsp;<TT>cobegin</TT></H3><!--SEC END -->

<A NAME="sec:parallel:cobegin"></A>
<!--NAME parallel.cobegin.html-->
<BR>
<BR>
The syntax of the <TT>cobegin</TT> statement is as follows, where <I>S</I> is
a DPJ statement:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>cobegin</TT> <I>S</I>
</DL>
If <I>S</I> is any statement but a block enclosed in curly braces <TT>{</TT>
&hellip; <TT>}</TT>, or if <I>S</I> is a block consisting of a single
statement, then the <TT>cobegin</TT> just executes the statement <I>S</I>.
Otherwise, the component statements of <I>S</I> are run as parallel tasks.
There is an implicit barrier (join) at the end of the <TT>cobegin</TT>
statement, so that all the component tasks must finish execution
before the parent task executes the statement after the <TT>cobegin</TT>.<BR>
<BR>
For example, the following code executes statements <TT>S1</TT> and
<TT>S2</TT> in parallel:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>cobegin</B></FONT> {
  S1;
  S2;
}
S3;</TT></DIV>Because <TT>S3</TT> appears after the <TT>cobegin</TT>, both <TT>S1</TT> and
<TT>S2</TT> are guaranteed to finish before <TT>S3</TT> is executed.<BR>
<BR>
In order to guarantee deterministic execution, the compiler checks the
component statements of a <TT>cobegin</TT> for noninterference
(Section&nbsp;<A HREF="#sec:effects:nonint">5.7</A>). If interference is discovered,
then the compiler issues a warning. For example, the following code
would cause a warning, because of the interfering writes to variable
<TT>x</TT> in the parallel tasks:

 <DIV CLASS="dpjlisting"><TT><B>class</B> C {
  <B>void</B> m() {
    <B>int</B> x;
    <FONT COLOR="blue"><B>cobegin</B></FONT> {
      x = 0;
      x = 1;
    }
  }
}</TT></DIV>On the other hand, the following code would compile with no warning:

 <DIV CLASS="dpjlisting"><TT><B>class</B> C {
  <B>void</B> m() {
    <B>int</B> x, y;
    <FONT COLOR="blue"><B>cobegin</B></FONT> {
      x = 0;
      y = 1;
    }
  }
}</TT></DIV><BR>
<BR>
The <TT>cobegin</TT> statement is most often used with recursion. The
following pattern is typical:

 <DIV CLASS="dpjlisting"><TT><B>void</B> recursiveMethod(...) {
  <B>if</B> (...) {
    <FONT COLOR="fuchsia"><EM>// do base case sequentially</EM></FONT>
  } <B>else</B> {
    <FONT COLOR="blue"><B>cobegin</B></FONT> {
      recursiveMethod(...);
      recursiveMethod(...);
    }
  }
}</TT></DIV>Note that the &#8220;recursion cutoff&#8221; (i.e., when the base case takes
over) has to be programmed manually. For example, in a parallel
recursive sort, the condition might say to do the sort sequentially
when the input array reaches a certain minimum size. The minimum
should be chosen so that (1) there are enough parallel tasks for the
scheduler to balance the computation, but (2) the task creation
overhead is not unduly large. See <EM>The Deterministic Parallel Java Tutorial</EM> for more
examples of <TT>cobegin</TT>.<BR>
<BR>
<!--TOC subsection 6.2&nbsp;&nbsp;<TT>foreach</TT>-->

<H3 CLASS="subsection"><A NAME="htoc59">6.2</A>&nbsp;&nbsp;<TT>foreach</TT><A NAME="sec:parallel:foreach"></A></H3><!--SEC END -->

<!--NAME parallel.foreach.html-->
<BR>
<BR>
<TT>foreach</TT> operates similarly to <TT>cobegin</TT>, except that the
parallel tasks are the iterations of a loop, instead of the component
statements of a block. The granularity of parallelism (i.e., how many
loop iterations to execute in a task) is controllable by the
programmer.<BR>
<BR>
<!--TOC subsubsection 6.2.1&nbsp;&nbsp;Writing the <TT>foreach</TT> loop-->

<H4 CLASS="subsubsection"><A NAME="htoc60">6.2.1</A>&nbsp;&nbsp;Writing the <TT>foreach</TT> loop<A NAME="sec:parallel:foreach:writing"></A></H4><!--SEC END -->

<!--NAME parallel.foreach.writing-->
<BR>
<BR>
The syntax of the <TT>foreach</TT> loop is as follows:
<DL CLASS="description" COMPACT=compact><DT CLASS="dt-description"><DD CLASS="dd-description"><TT>foreach (int
 </TT><EM>index-var</EM><TT> in </TT><EM>start</EM><TT>, </TT><EM>length</EM><TT>,
 </TT><EM>stride</EM><TT>) </TT><EM>body</EM><TT>;</TT>
</DL>
<TT>index-var</TT> is an identifier, <EM>start</EM>, <EM>length</EM>, and
<EM>stride</EM> are integer expressions, and <EM>body</EM> is a statement.
The <EM>stride</EM> expression is optional, and the default is 1. If it
appears, the <EM>stride</EM> expression must evaluate to an integer
greater that 0. The <TT>foreach</TT> loop executes the loop body once
for each element of an iteration space given by all integers
<I>stride</I> &sdot; <I>i</I> such that <I>i</I> ranges between 0 and
<I>length</I>&minus;1, inclusive. The variable <EM>index-var</EM> may
not be modified in the loop body.<BR>
<BR>
For example, the following code sets the cells of array <TT>A</TT> with
even indices to 0:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, A.length, 2) {
  A[i] = 0;
}</TT></DIV><BR>
<BR>
The compiler performs the following noninterference check for indexed
<TT>foreach</TT> loops:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Infer the effect set of <EM>body</EM>
 (Section&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A>).
<LI CLASS="li-enumerate">Create a copy of the effect set generated in (1), but replace
 every occurrence of <EM>index-var</EM> with a fresh variable that is
 known to be unequal to <EM>index-var</EM>. This simulates the effects
 generated by two distinct iterations of the loop, for which
 <EM>index-var</EM> will have distinct values.
<LI CLASS="li-enumerate">Check whether the effect sets generated in (1) and (2) are
 noninterfering (Section&nbsp;<A HREF="#sec:effects:nonint">5.7</A>).
</OL>
If interference is detected, the compiler issues a warning.<BR>
<BR>
The DPJ runtime divides the <TT>foreach</TT> iterations into parallel
work according to the programmer-specified granularity
(Section&nbsp;<A HREF="#sec:parallel:foreach:granularity">6.2.2</A>). As in the case of
<TT>cobegin</TT>, there is an implicit barrier at the end of the
<TT>foreach</TT>; i.e., all tasks created by the <TT>foreach</TT> must
complete before any code following the <TT>foreach</TT> is executed.<BR>
<BR>
<!--TOC subsubsection 6.2.2&nbsp;&nbsp;Controlling the granularity of parallelism-->

<H4 CLASS="subsubsection"><A NAME="htoc61">6.2.2</A>&nbsp;&nbsp;Controlling the granularity of parallelism<A NAME="sec:parallel:foreach:granularity"></A></H4><!--SEC END -->

<!--NAME parallel.foreach.granularity.html-->
<BR>
<BR>
In most cases, it would be inefficient to issue every loop iteration
as a parallel task. For example, consider a loop iterating over an
array with 100,000 elements on a machine with 10 cores. If 100,000
tasks were issued to do this computation, the task creation overhead
would swamp the parallelism.<BR>
<BR>
Instead, the DPJ compiler allows the user to control the granularity
of task creation. The user can specify a minimum task size, in terms
of the number of iterations. The compiler recursively splits the
iteration space, until the minimum size is reached. For example, if
the cutoff were specified to be 1000 in the example above, then the
compiler would divide the loop into 100 tasks of 1000 iterations
each.<BR>
<BR>
If the <TT>foreach</TT> computation is perfecly balanced (i.e., each
iteration does exactly the same amount of work), then it makes sense
to make the cutoff <I>I</I>/<I>T</I>, where <I>I</I> is the number of loop iterations
and <I>T</I> is the number of threads available to the DPJ runtime (usually
equal to the number of cores on the host machine). Using this
strategy, in the example with 100,000 iterations and 10 cores, the
cutoff should be 10,000.<BR>
<BR>
If the computation is not perfectly balanced, then a better strategy
is to <EM>over-decompose</EM> the computation, specifying more tasks
than the number of available threads. This allows the scheduler to
schedule multiple tasks of varying size per thread, in a such a way
that the aggregate amount of work per thread is roughly balanced. As
in the case of the <TT>cobegin</TT> cutoff
(Section&nbsp;<A HREF="#sec:parallel:cobegin">6.1</A>), the programmer should choose a
minimum task size that creates enough parallel work without incurring
too much task creation overhead.<BR>
<BR>
The precise mechanism for specifying the number of DPJ threads and the
<TT>foreach</TT> cutoff is implementation-dependent.
<EM>The Deterministic Parallel Java Installation and Testing Guide</EM> explains how this mechanism works for the <TT>dpjc</TT>
compiler.<BR>
<BR>

<!--TOC section 7&nbsp;&nbsp;The DPJ Runtime-->

<H2 CLASS="section"><A NAME="htoc62">7</A>&nbsp;&nbsp;The DPJ Runtime<A NAME="sec:runtime"></A></H2><!--SEC END -->

<!--NAME runtime.html-->
<BR>
<BR>
This section gives an overview of the classes <TT>DPJArray</TT> and
<TT>DPJPartition</TT> in the package <TT>DPJRuntime</TT>. These classes are
part of the runtime supplied with DPJ and are useful for manipulating
arrays. To use these classes, put the DPJ runtime
(<TT>DPJ/Implementation/Runtime/classes</TT>) in your class path and
either put <TT>import DPJRuntime.*</TT> at the head of your code, or
import just the classes you want to use. For full documentation of
these classes, and for coverage of the other DPJ runtime classes, see
the HTML documentation included in the DPJ release at
<TT>DPJ/Implementation/Runtime/dpjdoc</TT>.<BR>
<BR>
<!--TOC subsection 7.1&nbsp;&nbsp;<TT>DPJArray</TT>-->

<H3 CLASS="subsection"><A NAME="htoc63">7.1</A>&nbsp;&nbsp;<TT>DPJArray</TT><A NAME="sec:runtime:array"></A></H3><!--SEC END -->

<!--NAME runtime.array.html-->
<BR>
<BR>
In parallel algorithms that operate on arrays, especially
divide-and-conquer algorithms, it is often necessary to split an array
into parts and operate separately on the separate parts. Because this
operation is so useful, some languages (e.g., Fortran 90) include
first-class support for extracting such &#8220;slices&#8221; from arrays.
Unfortunately, Java does not. Instead of adding slices directly to
arrays, which would require redefining Java array types and array
operations (and would be hard to make consistent with legacy Java),
DPJ provides array slices as an operation of a library class, called
<TT>DPJArray</TT>. There are two kinds of <TT>DPJArray</TT> classes: the
generic <TT>DPJArray</TT> class, and a set of <TT>DPJArray</TT> classes
specialized to primitive types.<BR>
<BR>
<B>Generic <TT>DPJArray</TT>:</B> The generic <TT>DPJArray</TT> class
represents an array of objects. It has one type parameter and one RPL
parameter:

 <DIV CLASS="dpjlisting"><TT><B>class</B> DPJArray&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt;</TT></DIV>The type parameter is the element type of the array, and the RPL
parameter is the RPL of the array storage.<BR>
<BR>
<I>Creating a <TT>DPJArray</TT>:</I> There are three ways to create a
<TT>DPJArray</TT> object. The first is to call a constructor that takes
just a length argument. This operation creates a new <TT>DPJArray</TT>
with the specified length, type, and RPL. For example, the following
code creates a <TT>DPJArray</TT> storing 10 <TT>Integer</TT> objects, and
the storage is in RPL <TT>r</TT>:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>region</B></FONT> r;
DPJArray&lt;Integer,r&gt; A = <B>new</B> DPJArray&lt;Integer,r&gt;(10);</TT></DIV><BR>
<BR>
Creating a fresh DPJ array is useful, but sometimes you have a Java
array and you want to make a <TT>DPJArray</TT> out of it. So the second
way to create a <TT>DPJArray</TT> is to call a constructor that takes an
ordinary Java array as an argument. For example, the following code
creates a Java array of 10 <TT>Integer</TT> objects, and wraps it in a
<TT>DPJArray</TT>:

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>region</B></FONT> r;
Integer[]&lt;r&gt; a = <B>new</B> Integer[10]&lt;r&gt;;
DPJArray&lt;Integer,r&gt; A = <B>new</B> DPJArray&lt;Integer,r&gt;(a);</TT></DIV>Note that the type and RPL of the array being passed in (here,
<TT>Integer</TT> and <TT>r</TT>) must match the type and RPL argument of the
<TT>DPJArray</TT> type; if not, a compile error occurs.<BR>
<BR>
The third way to create a <TT>DPJArray</TT> is to make a <EM>subarray</EM>
(i.e., a slice) of an existing <TT>DPJArray</TT>. This is explained
below.<BR>
<BR>
<I>Accessing elements:</I> <TT>DPJArray</TT> has <TT>put</TT> and
<TT>get</TT> operations similar to the ones in <TT>java.util.ArrayList</TT>.
For example, if <TT>A1</TT> and <TT>A2</TT> are <TT>DPJArray</TT>s, then the
following code fragment gets element 0 out of <TT>A1</TT> and stores it
into element 0 of <TT>A2</TT>:

 <DIV CLASS="dpjlisting"><TT>A2.put(0, A1.get(0));</TT></DIV>If the <TT>DPJArray</TT> was created by wrapping a Java array, then the
<TT>put</TT> operation modifies the wrapped array. The effect of a
<TT>get</TT> operation is a read on the region of the <TT>DPJArray</TT>, and
the effect of a <TT>put</TT> operation is a write to the region of the
<TT>DPJArray</TT>.<BR>
<BR>
Accesses are bounds-checked. Any attempt to access a position less
than 0 or greater than the array length minus one throws an
<TT>ArrayIndexOutOfBoundsException</TT>.<BR>
<BR>
<I>Subarrays:</I> The real usefulness of <TT>DPJArray</TT> is its
support for <EM>subarrays</EM>, which are contiguous subsections of an
array. To create a subarray of a <TT>DPJArray</TT>, you call the
<TT>subarray</TT> instance method with a start and length argument. For
example, the following code creates a <TT>DPJArray</TT> and then extracts
the subarray of length 2 starting at position 5 (here we use the
default RPL of <TT>Root</TT>):

 <DIV CLASS="dpjlisting"><TT>DPJArray&lt;Integer&gt; A = <B>new</B> DPJArray&lt;Integer&gt;(10);
DPJArray&lt;Integer&gt; B = A.subarray(5,2);</TT></DIV><BR>
<BR>
There are two nice things about subarrays. First, creating a subarray
takes minimal time and space overhead. Nothing is copied, and no new
storage allocated to hold any array elements. A small object is
created that stores the start position, length, and a reference to the
underlying array.<BR>
<BR>
Second, as far as its API is concerned, a subarray is
indistinguishable from a freshly created <TT>DPJArray</TT>. For example,
the subarray created above is zero-indexed, it has length 2, and
attempts to access indices other than 0 and 1 throw an exception.
However, the subarray also provides a view into the original array.
For example, the following code stores 1 into position 0 of <TT>B</TT>,
which is the same as position 5 of <TT>A</TT>:

 <DIV CLASS="dpjlisting"><TT>B.put(0,1);</TT></DIV>You can get the start position out of a <TT>DPJArray</TT> by reading the
field <TT>start</TT>, and you can get the length by reading the field
<TT>length</TT>.<BR>
<BR>
These features allow methods that operate on array subranges to be
zero-indexed, without worrying about the index parameters of the
subranges. For example, here is some simple recursive code that
increments every position of a <TT>DPJArray</TT> by 1:

 <DIV CLASS="dpjlisting"><TT>&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> increment(DPJArray&lt;T,R&gt; A) {
    <B>if</B> (A.length == 0) <B>return</B>;
    <B>if</B> (A.length == 1) {
        A.put(0, A.get(0)+1);
    }
    <B>int</B> mid = A.length / 2;
    increment(A.subarray(0, mid));
    increment(A.subarray(mid, length-mid));
}</TT></DIV>Without the subarray feature, this code would have to be written by
passing the index ranges as parameters to the <TT>increment</TT> method,
which is ugly.<BR>
<BR>
<B>Specialized <TT>DPJArray</TT>s:</B> Because Java does not support
binding primitive types to generic parameters, the DPJ runtime also
has versions of <TT>DPJArray</TT> specialized to the primitive types
(<TT>DPJInt</TT> for <TT>int</TT>, <TT>DPJBoolean</TT> for <TT>boolean</TT>,
etc.). These operate identically to the generic <TT>DPJArray</TT>,
except that the element type is given by the class, and there is no
generic parameter.<BR>
<BR>
Another way to write such arrays is to create a generic <TT>DPJArray</TT>
using the class corresponding to the primitive type. For example,
instead of a <TT>DPJArrayInt</TT>, one could use a
<TT>DPJArray&lt;Integer&gt;</TT>, as described above. This works, but the code
is more verbose, as well as more memory-intensive and slower, as Java
has to box and unbox all those primitive types when putting them into
and getting them out of the array.<BR>
<BR>
<!--TOC subsection 7.2&nbsp;&nbsp;<TT>DPJPartition</TT>-->

<H3 CLASS="subsection"><A NAME="htoc64">7.2</A>&nbsp;&nbsp;<TT>DPJPartition</TT><A NAME="sec:runtime:partition"></A></H3><!--SEC END -->

<!--NAME runtime.partition.html-->
<BR>
<BR>
For parallel divide-and-conquer algorithms on arrays, it is often
important to create disjoint collections of subarrays. For example, a
parallel sorting algorithm might repeatedly divide an array into
disjoint halves (or quarters, etc.) and operate recursively in
parallel on the pieces. To support effect checking for this kind of
algorithm, the DPJ runtime includes a class <TT>DPJPartition</TT> for
representing disjoint collections of subarrays of the same array.
Each of the subarrays in the collection is called a <EM>segment</EM> of
the partition. As with <TT>DPJArray</TT>, there is a generic version,
and there are specialized versions.<BR>
<BR>
<B>Generic <TT>DPJPartition</TT>:</B> The generic <TT>DPJPartition</TT>
class represents an array of subarrays of a <TT>DPJArray</TT>. It has
one type parameter and one RPL parameter:

 <DIV CLASS="dpjlisting"><TT><B>class</B> DPJPartition&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt;</TT></DIV>The type parameter is the element type of the <TT>DPJArray</TT> being
partitioned, and the RPL parameter is the RPL of the array storage.<BR>
<BR>
<I>Creating a <TT>DPJPartition</TT>:</I> There are several ways to
create a <TT>DPJPartition</TT>; for a full list, see the HTML
documentation. Here are two useful ways. First, <TT>DPJPartition</TT>
has a constructor that takes a <TT>DPJArray</TT> to partition, an index
at which to partition, and a <TT>boolean</TT> value that says whether to
exclude or include the element at the index position. For example, if
<TT>A</TT> is a <TT>DPJArray&lt;Integer&gt;</TT> of length 10, then

 <DIV CLASS="dpjlisting"><TT><B>new</B> DPJArray&lt;Integer&gt;(A, 5, <B>true</B>)</TT></DIV>partitions <TT>A</TT> into the segments [0,4] and [6,9] (excluding
position 5), while

 <DIV CLASS="dpjlisting"><TT><B>new</B> DPJArray&lt;Integer&gt;(A, 5, <B>false</B>)</TT></DIV>partitions <TT>A</TT> into the segments [0,4] and [5,9] (including
position 5). This constructor is useful for parallel
divide-and-conquer algorithms with a fanout of 2.<BR>
<BR>
Second, <TT>DPJPartition</TT> has a static factory method
<TT>stridedPartition</TT> that takes a <TT>DPJArray</TT> to partition and a
stride at which to partition. For example, if <TT>A</TT> is a
<TT>DPJArray&lt;Integer&gt;</TT> of length 10, then

 <DIV CLASS="dpjlisting"><TT><B>new</B> DPJPartition&lt;Integer&gt;(A, 2)</TT></DIV>creates a <TT>DPJPartition&lt;Integer&gt;</TT> with five segments, each of
length 2. This feature is useful for parallel divide-and-conquer
algorithms with a fanout of greater than two, as well as flat
partitions (such as tiling an array).<BR>
<BR>
<I>Accessing segments:</I> The field <TT>length</TT> stores the number
of segments in the partition. It is <TT>final</TT>, so reading it has no
effect (§&nbsp;<A HREF="#sec:effects:stmt-exp">5.4</A>). The method <TT>get</TT> takes an
integer index <TT>idx</TT> and returns the segment corresponding to that
index (and throws an exception if the index is out of range). The
type of the segment is <TT>DPJArray&lt;T,this:[idx]:*&gt;</TT>.<BR>
<BR>
The index-parameterized type returned by <TT>get</TT> allows the
different segments to be operated on in parallel without interference,
similarly to an index-parameterized array
(§&nbsp;<A HREF="#sec:types:array:ipa">4.2.2</A>). For example, the following code uses
<TT>DPJPartition</TT> to parallelize the simple recursive <TT>increment</TT>
shown in §&nbsp;<A HREF="#sec:runtime:array">7.1</A>:

 <DIV CLASS="dpjlisting"><TT>&lt;<FONT COLOR="blue"><B>type</B></FONT> T, <FONT COLOR="blue"><B>region</B></FONT> R&gt;<B>void</B> parallelIncrement(DPJArray&lt;T,R&gt; A)
  <FONT COLOR="blue"><B>writes</B></FONT> R:* {
    <B>if</B> (A.length == 0) <B>return</B>;
    <B>if</B> (A.length == 1) {
        <FONT COLOR="fuchsia"><EM>// Effect is 'writes R'</EM></FONT>
        A.put(0, A.get(0)+1);
    }
    <B>int</B> mid = A.length / 2;
    <B>final</B> DPJPartition&lt;T,R&gt; segs = <B>new</B> DPJPartition&lt;T,R&gt;(A,mid)
    <FONT COLOR="blue"><B>cobegin</B></FONT> {
        <FONT COLOR="fuchsia"><EM>// Effect is 'writes segs:[0]:*'</EM></FONT>
        parallelIncrement(segs.get(0));
        <FONT COLOR="fuchsia"><EM>// Effect is 'writes segs:[1]:*'</EM></FONT>
        parallelIncrement(segs.get(1));
    }
}</TT></DIV>For more examples of how to use <TT>DPJPartition</TT>, see <EM>The Deterministic Parallel Java Tutorial</EM>.<BR>
<BR>
The variable <TT>this</TT> in the type gets substituted by the selector
expression at the call site (§&nbsp;<A HREF="#sec:types:exp:invoke">4.3.3</A>), so it is
usually most useful to call <TT>get</TT> through a <TT>final</TT> local
variable. Including the variable in the RPL ensures that the compiler
doesn't erroneously infer disjointness for two different partitions of
the same array. For example, in the following code,
<TT>segs1.get(1)</TT> and <TT>segs2.get(0)</TT> are not disjoint (they
overlap at [2,7]):

 <DIV CLASS="dpjlisting"><TT>DPJArray&lt;Integer&gt; A = <B>new</B> DPJArray&lt;Integer&gt;(10);
<FONT COLOR="fuchsia"><EM>// Create segments [0,1] and [2,9]</EM></FONT>
DPJPartition&lt;Integer&gt; segs1 = <B>new</B> DPJPartition(A, 2);
<FONT COLOR="fuchsia"><EM>// Create segments [0,7] and [8,9]</EM></FONT>
DPJPartition&lt;Integer&gt; segs2 = <B>new</B> DPJPartition(A, 8);</TT></DIV><BR>
<BR>
<B>Specialized <TT>DPJPartition</TT>s:</B> As with <TT>DPJArray</TT>,
there are versions of <TT>DPJPartition</TT> specialized to the various
primitive types. They are provided for convenience and efficiency, as
Java does not support binding primitive types to generic type
parameters.<BR>
<BR>

<!--TOC section 8&nbsp;&nbsp;Exception Behavior-->

<H2 CLASS="section"><A NAME="htoc65">8</A>&nbsp;&nbsp;Exception Behavior<A NAME="sec:exceptions"></A></H2><!--SEC END -->

<!--NAME exceptions.html-->
<BR>
<BR>
In DPJ, an exception thrown outside any parallel construct
(<TT>cobegin</TT> or <TT>foreach</TT>) behaves exactly as in sequential
Java. An exception thrown inside a parallel construct and caught
inside that same parallel construct also behaves as in sequential
Java. An exception thrown inside a parallel construct and not caught
inside that parallel construct has the following behavior:
<OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
If an exception <I>E</I> is thrown in branch <I>B</I> of a <TT>cobegin</TT>
 or <TT>foreach</TT>, then branch <I>B</I> behaves as if it were executed in
 isolation, starting with the state that existed at the start of the
 <TT>cobegin</TT> or <TT>foreach</TT>. For example, consider this code,
 where <TT>loopBody(int)</TT> is a method:<BR>
<BR>

 <DIV CLASS="dpjlisting"><TT><FONT COLOR="blue"><B>foreach</B></FONT> (<B>int</B> i <FONT COLOR="blue"><B>in</B></FONT> 0, 10) {
    loopBody(i);
}</TT></DIV><BR>
<BR>
If iteration <I>I</I> throws exception <I>E</I>, then replacing the entire
<TT>foreach</TT> with <TT>loopBody(I)</TT> would also cause <I>E</I> to be
thrown, at the same point in the execution of method <TT>loopBody</TT> as
in the parallel case.<BR>
<BR>
<LI CLASS="li-enumerate">If multiple branches of a <TT>cobegin</TT> or <TT>foreach</TT>, each
 run in isolation, would throw an exception, then one of those
 exceptions is guaranteed to be thrown by the entire <TT>cobegin</TT> or
 <TT>foreach</TT>. Which one is thrown is scheduler dependent (i.e.,
 different ones may be thrown on different executions).<BR>
<BR>
<LI CLASS="li-enumerate">Methods annotated <TT>commutative</TT>
 (Section&nbsp;<A HREF="#sec:classes:methods:commutative">2.3.4</A>) must respect this
 exception behavior. For instance, method invocations <I>I</I><SUB>1</SUB> and
 <I>I</I><SUB>2</SUB> are not considered to commute with each other if execution
 <I>I</I><SUB>1</SUB>; <I>I</I><SUB>2</SUB> throws an exception, but <I>I</I><SUB>2</SUB>; <I>I</I><SUB>1</SUB> does not.</OL>



<!--NAME references.html-->
<BR>
<BR>
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
<A HREF="http://pauillac.inria.fr/~maranget/hevea/index.html">H<FONT SIZE=2><sup>E</sup></FONT>V<FONT SIZE=2><sup>E</sup></FONT>A</A>.</EM></BLOCKQUOTE></BODY>
</HTML>
